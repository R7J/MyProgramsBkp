#!/usr/bin/expect --
# $Author: Savari $   : Author of last commit
###

# linux install instruction:;
#  packages to install: tcllib, expect

# common functions for Mobiwave and StreetWave automation
package require cmdline
package require Expect
# default values
set username         		"root"
set boxPassword     		""
set localHostPassword		"savari"
set dutPromptStr		"unknown"
set durPromptStr	        "unknown"
set localHostPromptStr		"unknown"

set site 			"bangalore.savarinetworks.com"

set debug            		0
set isUpdateConfig   		0
set preImageFile                "StreetWAVE-x86-jffs2-64k.image"
set buildType                   2
set preDurImageFile    		""
set preImageUpgradeCleanConfig 	0
set logFile          		"log.txt"  
set logFileHdl       		""
set summaryFile      		"summaryFile.txt"
set ignoreTrap      	 	0
set stopAtFail       		0

set dutBoxIp         		"192.168.20.123"	
set ndutBoxIp                   "192.168.20.22"			
set dutBoxMac        		"??:??:??:??:??:??"
set dutWifiMac       		"??:??:??:??:??:??"
set dutDsrcMac       		"??:??:??:??:??:??"
set dutBtMac         		"??:??:??:??:??:??"
set dutBoxMacIntfName 		"eth0"
set dutIsRsu          		0
set dsrcIntfName      		"ath0"
set dutDsrcIp         		"192.168.3.1"
set dutWifiIp        		""
set dutWifiIntfName   		"ath1"
set durBoxIp          		"192.168.20.107"		
set durIsRsu          		0
set durDsrcIp        		"192.168.3.2"
set durWifiIp        		""
set durWifiIntfName   		"ath1"
set hostWifiIntfName    	"wlan0"
set btIntfName         		"hci0"
set stbtClientId     		"6019"
set btServerKillSec   		5
set btScanSec         		30
set gpsDevName         		"/dev/ttyGPS"
set threegRebootTestCount 	10
set testName			""
set dutSpawnId                  ""

set gpsLat             		""
set gpsLong            		""
set wifiChan           		""
set wifiEssid          		""
set dsrcChan           		"176"
set dsrcEssid          		"gemsdsrcnet"
set pingNumPkts        		2
set iperfTimeSecs      		5
set expWiFiPerfSpeedMbits	0
set expDsrcNoChanSwitchPerfSpeedMbits   2	
set expDsrcChanSwitchPerfSpeedMbits     2	
set expEthernetSpeedMbits		50

set logFileLocation		"/home/savari/Desktop/Automation"		
set btScanTimeSecs		2 
set expBtScanFoundCount		25
set scpRemoteIp			"192.168.20.180"		
set scpRemoteUsername		"savari"
set scpRemoteFile1Name		"/home/savari/Documents/Automation/t.txt"
set scpFile1Name		"/mnt/usbdrv/savari/t.txt"
set scpRemoteFile1Path		"/mnt/usbdrv/savari/"
set  copyOut			10

set scpRemoteFileName		"/home/savari/Desktop/Automation/ppstest.tar.gz"
set scpRemoteFilePath		"/usr/local/bin/"
set scpFileName 		"ppstest.tar.gz"

#set webPowerSwitchOn		"wget --no-proxy -O /dev/null -q --auth-no-challenge 'http://admin:1234@192.168.10.100/outlet?a=ON'"
#set webPowerSwitchOff           "wget --no-proxy -O /dev/null -q --auth-no-challenge 'http://admin:1234@192.168.10.100/outlet?a=OFF'"

set savariWMEdPath     		"/etc/init.d/savari16093 start"
set savariWAVEAppPath  		"/usr/local/bin/BSMapp"
set savariWMEd        		"savari16093d"
set cycurvpath	       		"/etc/init.d/cycurv2x start"
set savariWaveApp     		"BSMapp"
set savariDsrcApps    		[list $savariWMEd $savariWaveApp]
set savariDisableNtpOneTimeFileName	"/etc/disableNTPOneTime"
set dutIsRsuFailSafe   		0
set timeout            		10
set btTimeout          		2

# general timeout value
set  commonTimeoutSecs   	3
# timeout for hostapd kill
set hostApdKill2TimeoutSecs   	15
# timeout for wpasupplicant kill
set wpaSuppKill2timeoutSecs   	10
# wait for this seconds after running each test
set testBetweenSecs        	2
# wifi channel switch seconds
set  wifiChanSwitchSecs    	30
# wifi association time
set  wifiAssocSecs        	10
# uci set tit for this seconds after running each test
set  uciSetSecs              	5
set  killAllUdhcpcSecs       	10
set  fwUpgradeWaitSecs     	180
# for onboard flash upgrade in case of fail safe image, it takes more time
set  fwUpgradeFSWaitSecs      	480
set  rebootTimeSecs       	40
set  rebootWaitFSAfterUpgradeSecs	300	
set  rebootWaitAfterUpgradeSecs   	160

set  closeSpawnIdSecs       	5
set  dsrcAppKillSecs          	4
# wait time for wmed to start
set wmedStartTime		2
# wait for this many seconds after watchdog is killed
# 60 seconds for watchdog then 80 seconds for reboot 
set watchdogWaitSecs        	140
# wait for this many seconds for ntpclient to finish updating time 
set ntpUpdateWaitSecs        	60
set iperfTransferSpeed 		54

set testsRegExp        		"timapp_test|dsrcproxy_test|gps_test|pps_test|channel_test|datarate_test|txpower_test|ipv6_test|status1_test|system_test"
set rsuManufactureTestRegExp 	"rsuManufactureTest"
set obuManufactureTestRegExp 	"obuManufactureTest"
set rsuFailSafeTestRegExp   	"rsuFailSafeTest"
set testListToExecute  		""
set randomizeTests     		0
set executeFromFile    		""
set saveTestExecutionListToFile	""

# logs the text into output as well as to an audit file
proc log {text} {

    set textStart        [string trimleft $text ?\n?]
    set leadingNewLines  [expr [string length $text] - [string length $textStart] - 1]
    set leadingNewLineStr [string range $text 0 $leadingNewLines]
    if { $textStart == "" } {
	# if msg consists of only newlines, do not print LOG
	send_user "${leadingNewLineStr}\n"
	send_log "${leadingNewLineStr}"
    } else {
	send_user "${leadingNewLineStr}LOG: $textStart\n"
	send_log "${leadingNewLineStr}LOG: $textStart"
    }
}


# Command line options
set optList [list \
    [list debug     "turns on debug mode"] \
    [list updateconfig  "don't overwrite the config of the box"] \
    [list buildType  "specify buildtype"] \
    [list preImageFile.arg "" "image to upgrade on DUT before the test"] \
    [list preDurImageFile.arg "" "image to upgrade on DUR before the test"] \
    [list preImageUpgradeCleanConfig  "clean config when upgrading pre image"]\
    [list logFile.arg "$logFile"  "log file for saving output"] \
    [list summaryFile.arg ""      "log file for saving summary"] \
    [list localHostPassword.arg "$localHostPassword" "local host password"] \
    [list dutBoxIp.arg "$dutBoxIp" "DUT(Device under test) IP"] \
    [list scpRemoteIp.arg "$scpRemoteIp " "Host Systems IP"] \
    [list dutDsrcIp.arg "$dutDsrcIp" "DUT DSRC IP"] \
    [list dutWifiIp.arg "$dutWifiIp" "DUT WiFi IP"] \
    [list durBoxIp.arg "$durBoxIp" "DUR(device under reference) IP"] \
    [list durDsrcIp.arg "$durDsrcIp" "DUR(device under reference) DSRC IP"] \
    [list durWifiIp.arg "$durWifiIp" "DUR(device under reference) WiFi IP"] \
    [list dutWifiIntfName.arg "$dutWifiIntfName" "Dut wifi intf name" ]\
    [list lat.arg "" "GPS reference Latitude"] \
    [list long.arg "" "GPS reference Longitude"] \
    [list threegRebootTestCount.arg "$threegRebootTestCount" "threeg reboot test reboot count"]\
    [list wifiChan.arg "$wifiChan" "WiFi Channel to test"] \
    [list dsrcChan.arg "$dsrcChan" "DSRC Channel to test"] \
    [list pingNumPkts.arg "$pingNumPkts" "Number of default ping pkts in ping test"]\
    [list iperfTimeSecs.arg "$iperfTimeSecs" "iperf duration"]\
    [list expWiFiPerfSpeedMbits.arg "$expWiFiPerfSpeedMbits" "expected rate for iperf over wifi, specify 0 to overwrite the comparision"]\
    [list expDsrcNoChanSwitchPerfSpeedMbits.arg "$expDsrcNoChanSwitchPerfSpeedMbits" "expected rate for iperf over dsrc without channel switch, specify 0 to overwrite the comparision"]\
    [list expDsrcChanSwitchPerfSpeedMbits.arg "$expDsrcChanSwitchPerfSpeedMbits" "expected rate for iperf over dscrc with channel switch, specify 0 to overwrite the comparision"]\
    [list btScanTimeSecs.arg "$btScanTimeSecs" "bt scan curation in seconds"]\
    [list expBtScanFoundCount.arg  "$expBtScanFoundCount" "expected minimum number of devices found"]\
    [list testsRegExp.arg "$testsRegExp" "regexp for tests to execute. ex: battery_test"]\
    [list randomizeTests "randomize textcase execution"]\
    [list executeFromFile.arg "" "specify the file name with list of tests."]\
    [list saveTestExecutionListToFile.arg "" "specify the filename to save the test list."]\
    [list stopAtFail "stop when test fails"]\
    [list iperfTransferSpeed.arg "" "specify the bandwidth for udp transfer"]\
 ]

proc logTestParams {} {

    global optList isUpdateConfig sysinstall_file
    global gpsLat gpsLong debug unit logFile preImageFile summaryFile preImageUpgradeCleanConfig
    global dutBoxIp dutDsrcIp dutWifiIp durBoxIp durDsrcIp durWifiIp dutWifiIntfName durWifiIntfName
    global wifiChan wifiEssid dsrcChan dsrcEssid pingNumPkts iperfTimeSecs
    global testsRegExp randomizeTests expWiFiPerfSpeedMbits  expDsrcNoChanSwitchPerfSpeedMbits expDsrcChanSwitchPerfSpeedMbits
    global localHostPassword
    global btScanTimeSecs expBtScanFoundCount
    global stopAtFail buildType

    log "buildType:$buildType"
    log "debug:$debug, isUpdateConfig:$isUpdateConfig"
    log "preImageFile:$preImageFile, preImageUpgradeCleanConfig: $preImageUpgradeCleanConfig, logFile:$logFile, summaryFile:$summaryFile"
    log "dutBoxIp: $dutBoxIp,  dutWifiIntfName: $dutWifiIntfName, dutWifiIp: $dutWifiIp, dutDsrcIp: $dutDsrcIp"
    log "durBoxIp: $durBoxIp, durWifiIntfName: $durWifiIntfName, durWifiIp: $durWifiIp, durDsrcIp: $durDsrcIp"
    log "dsrcChan: $dsrcChan, dsrcEssid: $dsrcEssid expDsrcNoChanSwitchPerfSpeedMbits=$expDsrcNoChanSwitchPerfSpeedMbits, expDsrcChanSwitchPerfSpeedMbits=$expDsrcChanSwitchPerfSpeedMbits"
    log "wifiChan: $wifiChan wifiEssid: $wifiEssid expWiFiPerfSpeedMbits=$expWiFiPerfSpeedMbits"
    log "bt scan time: $btScanTimeSecs, bt scan expected count:  $expBtScanFoundCount"
    log "GPS lat:  $gpsLat, GPS long: $gpsLong"
    log "pingNumPkts: $pingNumPkts, iperfTimeSecs=$iperfTimeSecs"
}


proc parseCmdLine {argv} {
    global logFileHdl 
    global optList isUpdateConfig sysinstall_file executeFromFile saveTestExecutionListToFile
    global gpsLat gpsLong buildType debug unit logFile preImageFile summaryFile preImageUpgradeCleanConfig preDurImageFile
    global dutBoxIp dutDsrcIp dutWifiIp durBoxIp durDsrcIp durWifiIp dutWifiIntfName durWifiIntfName
    global wifiChan wifiEssid dsrcChan dsrcEssid pingNumPkts iperfTimeSecs threegRebootTestCount
    global testsRegExp randomizeTests expWiFiPerfSpeedMbits  expDsrcNoChanSwitchPerfSpeedMbits expDsrcChanSwitchPerfSpeedMbits
    global localHostPassword
    global btScanTimeSecs expBtScanFoundCount
    global stopAtFail iperfTransferSpeed scpRemoteIp

    set ret [catch { array set params \
        [::cmdline::getoptions argv $optList]} errStr]
    if {$ret > 0} {
        puts stderr "ERR:Parsing of options failed"
	puts stderr "$errStr"
	exit 1
    }

    # Show debug messages?
    if {$params(debug) > 0} {
        set debug 1
    }

    if {$params(stopAtFail)} {
	set stopAtFail 1
    }

    if {$params(updateconfig) > 0} {
        set isUpdateConfig 1
    }
    if {$params(preImageFile) != "" } {
        set preImageFile $params(preImageFile)
    }
    if {$params(preDurImageFile) != "" } {
        set preDurImageFile $params(preDurImageFile)
    }
    if {$params(preImageUpgradeCleanConfig) > 0 } {
        set preImageUpgradeCleanConfig 1
    }

    if {$params(logFile) != "" } {
        set logFile $params(logFile)
    }
    if {$params(summaryFile) != "" } {
        set summaryFile $params(summaryFile)
    }

    if {$params(localHostPassword) != "" } {
        set localHostPassword $params(localHostPassword)
    }

    if {$params(dutBoxIp) != "" } {
        set  dutBoxIp $params(dutBoxIp)
    }
    if {$params(dutDsrcIp) != "" } {
        set  dutDsrcIp $params(dutDsrcIp)
    }
    if {$params(dutWifiIp) != "" } {
        set  dutWifiIp $params(dutWifiIp)
    }
    if {$params(dutWifiIntfName) != "" } {
        set  dutWifiIntfName $params(dutWifiIntfName)
    }
    if {$params(durBoxIp) != "" } {
        set  durBoxIp $params(durBoxIp)
    }
    if {$params(durDsrcIp) != "" } {
        set  durDsrcIp $params(durDsrcIp)
    }
    if {$params(durWifiIp) != "" } {
        set  durWifiIp $params(durWifiIp)
    }

    if {$params(wifiChan) != "" } {
        set wifiChan $params(wifiChan)
    }

    if {$params(dsrcChan) != "" } {
        set dsrcChan $params(dsrcChan)
    }

    if {$params(pingNumPkts) != "" } {
        set pingNumPkts $params(pingNumPkts)
    }

    if {$params(iperfTimeSecs) != "" } {
        set iperfTimeSecs $params(iperfTimeSecs)
    }

    if {$params(expWiFiPerfSpeedMbits) != "" } {
        set expWiFiPerfSpeedMbits $params(expWiFiPerfSpeedMbits)
    }

    if {$params(expDsrcNoChanSwitchPerfSpeedMbits) != "" } {
        set expDsrcNoChanSwitchPerfSpeedMbits $params(expDsrcNoChanSwitchPerfSpeedMbits)
    }

    if {$params(expDsrcChanSwitchPerfSpeedMbits) != "" } {
        set expDsrcChanSwitchPerfSpeedMbits $params(expDsrcChanSwitchPerfSpeedMbits)
    }


    if {$params(lat) != "" } {
        set gpsLat $params(lat)
    }
    if {$params(long) != "" } {
        set gpsLong $params(long)
    }

    if {$params(threegRebootTestCount) != "" } {
        set threegRebootTestCount $params(threegRebootTestCount)
    }

    if {$params(btScanTimeSecs) != "" } {
	set btScanTimeSecs $params(btScanTimeSecs)
    }
   
    if {$params(expBtScanFoundCount) != "" } {
	set expBtScanFoundCount $params(expBtScanFoundCount)
    }
 
    if {$params(testsRegExp) != "" } {
        set testsRegExp $params(testsRegExp)
    }

    if {$params(randomizeTests) > 0 } {
        set randomizeTests 1
    }

    if {$params(iperfTransferSpeed) != "" } {
        set iperfTransferSpeed $params(iperfTransferSpeed) 
    }

    if {$params(executeFromFile) != "" } {
        set executeFromFile $params(executeFromFile)
    }

    if {$params(saveTestExecutionListToFile) != "" } {
        set saveTestExecutionListToFile $params(saveTestExecutionListToFile) 
    }
    
	if {$params(scpRemoteIp) != "" } {
        set scpRemoteIp $params(scpRemoteIp) 
    }
 #   if {$params(buildType) > 0 } {
#        set buildType 1
#}

    # open the log file
    if { [catch {set logFileHdl [open $logFile a+]}] != 0 } {
	puts stderr " Unable to open $logFile. Try specifying through -logFile option"
	exit 1
    }

    logTestParams
}


# will return the length of common prefix string
proc strMatch {str1 str2} {
    set len [string length $str1]
    for {set i 0} {$i < $len} {incr i} {
        if {[string index $str1 $i] != [string index $str2 $i]} {
            break
        }
    }
    return [expr $i -1]
}

# gets the mac address of the interface
# returns list of staus code and string
#  in case of error, string would be error msg
#  in case of success, mac addr string
proc getMac {intf promptStr} {
    global btIntfName

    if { $btIntfName != $intf } {
        send "ifconfig $intf\r"
    } else {
        send "ifconfig\r"
    }

    expect {

        "Device not found" {
            return [list 1 "interface $intf not found"]
        }

        -re "HWaddr (\[0-F]*)" {
            set mac $expect_out(1,string)
        }

        -re "BD Address: (\[0-F]*)" {
            set mac $expect_out(1,string)
        }

        -timeout 10 {
            return [list 1 "timeout fetching MAC address for $intf"]
        }
    }

    expect $promptStr
    return [list 0 $mac]
}

#clears current expect buffer
proc clearExpectBuf { promptStr } {
    set rareString "clearExpectBuf"
    send "echo $rareString\r"
    expect "echo $rareString"
    expect "$rareString"
    expect $promptStr
}


# handles ssh prompt by the remote machine 
#  assumes caller sets spawnid properly
# inputs:
#     password
# output
#  list of status and prompt
proc handle_login_prompt { password timeoutSecs } {

    while 1 {

        expect {

	    -timeout $timeoutSecs

            "assword: $" {
                send "${password}\r"
            }
            "Password:$" {
                send "${password}\r"
               }
            "yes/no" {
                   send "yes\r"
            }
            "y/n" {
                send "y\r"
            }
            "Terminal type" {
                send "xterm\r"
                interact
                break
            }
            "Operation timed out" {
                return [list 1 "Operation timedout"]
            }
            "Host key verification failed" {
                return [list 1 "Key verification failed. Why? we do clear ssh key"]
            }

	    # streetwave, mobiwave prompt
	    -re "root@(.*):~\#" {
		#figure out the box current hostname.It might have changed 
		#from system defaults. It is useful in the cases where testing 
		#need to run again  on boxes that are tested and reconfigured.

		set promptStr $expect_out(0,string)
		return [list 0 $promptStr]
	    }

	    # fedora 11 prompt
            -re "(.*)root@(.*)\# " {
                #figure out the box current hostname.It might have changed 
                #from system defaults. It is useful in the cases where testing 
                #need to run again  on boxes that are tested and reconfigured.

                set promptStr $expect_out(2,string)
                puts "My $promptStr"
		return [list 0 $promptStr]
            }
	    sleep 1
	    "No such file or directory" {
		return [list 1 "No such file or directory"]
	    }

            timeout {
                return [list 1 "Waited long enough for expected resp. while logging in"]
            }
            eof {
		return [list 1 "eof rcvd"]
            }
        }
    }
}



# connect to ftp server

proc connect {} {
	expect {
		"Name*:" {
			send "builduser\r"
			expect {
				"Password:" {
				 send "s@v@r!\r"
				 expect "login ok*ftp>"
  				 return 0
					}		
				}
			}
		}
# timed out
return 1
}

# log into the box of given ip addr
#
# returns:
#   in case of error,
#       status code, string contains error string
#   in case of success
#         status code, promptStr, spawnId
proc login_to_box {ipaddr password port} {
    global username
    global spawn_id
    set promptStr "unknown"
    set exitVal 0

    # Deleting known_host on Localhost
    file delete -force ~/.ssh/known_hosts

    set my_spawn_id [spawn -noecho ssh $ipaddr -l $username -p $port]


    if { $my_spawn_id == 0 } {
	set sleepSecs 1
	log "spawn failed. Redo span after $sleepSecs seconds"
	sleep $sleepSecs
	set my_spawn_id [spawn -noecho ssh $ipaddr -l $username -p $port]
	if { $my_spawn_id == 0 } {
	    return [list 1 "unable to spawn for $ipaddr"]
	}
    }

    while 1 {

        expect {

	    -timeout 10

            "assword: $" {
                send "${password}\r"
            }
            "Password:$" {
                send "${password}\r"
               }
            "yes/no" {
                   send "yes\r"
            }
            "y/n" {
                send "y\r"
            }
            "Terminal type" {
                send "xterm\r"
                interact
                break
            }
            "Operation timed out" {
                return [list 1 "Operation timedout"]
            }
            "Host key verification failed" {
                return [list 1 "Key verification failed. Why? we do clear ssh key"]
            }

	    # streetwave, mobiwave prompt
	    -re "(root@(.*)):~\#" {
		#figure out the box current hostname.It might have changed 
		#from system defaults. It is useful in the cases where testing 
		#need to run again  on bopxes that are tested and reconfigured.

		set promptStr $expect_out(1,string)
		break;
	    }

	    # fedora 11 prompt
            -re "(.*)root@(.*)\# " {
                #figure out the box current hostname.It might have changed 
                #from system defaults. It is useful in the cases where testing 
                #need to run again  on boxes that are tested and reconfigured.

                set promptStr $expect_out(2,string)
                break;
            }

            timeout {
                return [list 1 "Waited long enough for expected resp. while logging in"]
            }

            eof {
		return [list 1 "eof rcvd"]
            }
        }
    }

    # sleep for 2 seconds so that all the login output will be cleared
    sleep 2
    clearExpectBuf $promptStr ;#clearout the buffer

    # add expect_after for timing out on prompt
    expect_after {
	timeout  {
            return [list 1 "timeout waiting for prompt"]
	}
    }
    return [list 0 "$promptStr" $spawn_id]
}



# copies the file into the box
# Inputs:
#   scpRemoteIp -   scp remote machine ipaddr
#   scpRemoteUsername - scp remote machine username
#   scpRemoteFileName - file on scp remote machine
#   scpSpawnId -  of a machine where scp cmd is being executed
#   scpPromptStr - of a machine where scp cmd is being executed
#   scpFileName - file on a machin where scp cmd is being executed
#   copyOut - 1 in case of copying out of scp box, 0 when into the box
#
# returns:
#   in case of error, string contains error string
#   in case of success
#         status code, promptStr
proc scpFile { scpRemoteIp scpRemoteUsername localHostPassword scpRemoteFileName scpSpawnId scpPromptStr scpFileName copyOut scpRemoteFilePath} {
   
    global logFileLocation 
    global spawn_id 
    set spawn_id $scpSpawnId 
    clearExpectBuf $scpPromptStr

    
    # spawn the session

    send "rm -rf ~/.ssh/known_hosts \r"
    expect $scpPromptStr


    if { $copyOut == 0 } {
     send "scp $scpFileName $scpRemoteUsername@$scpRemoteIp:\r"		
    } else {
      
      send "scp -r $scpRemoteUsername@192.168.20.180:$scpRemoteFileName $scpRemoteFilePath\r"		
    }

    # wait until scp finishes
    set ret [handle_login_prompt $localHostPassword 80]
    if { [lindex $ret 0 ] != 0 } {
	set errStr "unable to send file to host using SCP:"
	append errStr [lindex $ret 1]
	return [list [lindex $ret 0] $errStr]	
    }
    set retStr "$scpRemoteFileName"

   return [list 0 $retStr ] 
}


# copies the file into USB inside the box
# returns:
#   in case of error, string contains error string
#   in case of success
#         status code, promptStr


proc scpFileUsb { scpRemoteIp scpRemoteUsername localHostPassword scpRemoteFileName scpSpawnId scpPromptStr scpFileName copyOut scpRemoteFilePathUsb} {
   
    global spawn_id logFileLocation
  
    set spawn_id $scpSpawnId
    clearExpectBuf $scpPromptStr

   
    # spawn the session
 
    if { $copyOut == 0 } {
     send "scp $scpFileName $scpRemoteUsername@$scpRemoteIp:\r"
    } else {
       send "scp -r $scpRemoteUsername@$scpRemoteIp:$scpRemoteFileName $scpRemoteFilePathUsb\r"
    }

    # wait until scp finishes
    set ret [handle_login_prompt $localHostPassword 30]
    if { [lindex $ret 0 ] != 0 } {
        set errStr "unable to send file to host using SCP:"
        append errStr [lindex $ret 1]
        return [list [lindex $ret 0] $errStr]
    }
    return [list 0 "" ""]
}

# Verifies the BSMs are able to trasmit or not
# returns:
#   in case of error, string contains error string
#   in case of success
#         status code, promptStr
proc bsmTransmit { dutSpawnId } {

    global spawn_id
    global dutPromptStr

    set testName                "bsmForward       "
    set resultStr               " "
    set testPassed              0
    set prevbsm                 0
    set presbsm                 0

#    log "LOGGING ON TO DUT\n"
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr ;#clearout the buffer

    # make sure it is ready to rcv command
    send "\r"
    expect $dutPromptStr

    sleep 5
    send "rse_stats -b\r"
    expect {
        -re "Fowarded BSMs                 : (\[0-9]+)" {
        set prevbsm $expect_out(1,string)

        }
          "$dutPromptStr" {
        }
    }


   sleep 5
   send "rse_stats -b\r"
   sleep 5
   expect {
       -re "Fowarded BSMs                 : (\[0-9]+)" {
       set presbsm $expect_out(1,string)
       }
         "$dutPromptStr" {
       }
   }


    set bsmCount [ expr $presbsm - $prevbsm ]
puts "$bsmCount"
if { $bsmCount == 0 } {
append resultStr "bsm  is not functional."
        set testPassed 0
    } else {
    log  "bsm is functional."
    set testPassed 1
    }

    if { $testPassed == 1 } {
        set testFailed 0
    } else {
        set testFailed 1
    }


 return [list $testFailed $resultStr $bsmCount]

}





# Verifies the WSMs are able to trasmit or not
# returns:
#   in case of error, string contains error string
#   in case of success
#         status code, promptStr
proc wsmpTransmit { dutSpawnId } {

    global spawn_id
    global dutPromptStr

    set testName                "wsmpForward       "
    set resultStr               " "
    set testPassed              0
    set prevwsmp                 0
    set preswsmp                 0

#    log "LOGGING ON TO DUT\n"
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr ;#clearout the buffer

    # make sure it is ready to rcv command
    send "\r"
    expect $dutPromptStr

    sleep 5
    send "rse_stats -w\r"
    expect {
        -re "Forwarded Packets Over Dsrc     : (\[0-9]+)" {
        set prevwsmp $expect_out(1,string)

        }
          "$dutPromptStr" {
        }
    }


   sleep 5
   send "rse_stats -w\r"
   sleep 5
   expect {
       -re "Forwarded Packets Over Dsrc     : (\[0-9]+)" {
       set preswsmp $expect_out(1,string)
       }
         "$dutPromptStr" {
       }
   }


    set wsmpCount [ expr $preswsmp - $prevwsmp ]
puts "$wsmpCount"
if { $wsmpCount == 0 } {
append resultStr "wsmpforward  is not functional."
        set testPassed 0
    } else {
    log  "wsmpforward is functional."
    set testPassed 1
    }

    if { $testPassed == 1 } {
        set testFailed 0
    } else {
        set testFailed 1
    }


 return [list $testFailed $resultStr $wsmpCount]

}



# Verifies the WSAs 
# returns:
#   in case of error, string contains error string
#   in case of success
#         status code, promptStr


proc wsaTransmit { dutSpawnId } {

    global spawn_id
    global dutPromptStr

    set testName                "WSA Transmission       "
    set resultStr               " "
    set testPassed              0
    set prevwsa                 0
    set preswsa                 0

#    log "LOGGING ON TO DUT\n"
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr ;#clearout the buffer

    # make sure it is ready to rcv command
    send "\r"
    expect $dutPromptStr

    #send "/usr/local/etc/savari/ipv6app stop\r"
    #expect  $dutPromptStr

    #send "/usr/local/bin/savari/ipv6app start\r"
    #expect  $dutPromptStr

    sleep 5
    send "rse_stats -i\r"
    expect {
        -re "Wsa Tx Packet            : (\[0-9]+)" {
        set prevwsa $expect_out(1,string)

        }
          "$dutPromptStr" {
        }
    }


   sleep 10
   send "rse_stats -i\r"
   sleep 5
   expect {
       -re "Wsa Tx Packet            : (\[0-9]+)" {
       set preswsa $expect_out(1,string)

       }
         "$dutPromptStr" {
       }
   }


    set wsaCount [ expr $preswsa - $prevwsa ]
puts "$wsaCount"
if { $wsaCount == 0 } {
append resultStr "ipv6  is not functional."
        set testPassed 0
    } else {
    log  "ipv6 is functional."
    set testPassed 1
    }

    if { $testPassed == 1 } {
        set testFailed 0
    } else {
        set testFailed 1
    }

                                                                                                                    
 return [list $testFailed $resultStr $wsaCount]

}


# Verifies the upload 
# returns:
#   in case of error, string contains error string
#   in case of success
#         status code, promptStr

proc upLoad { dutSpawnId } {

    global spawn_id
    global dutPromptStr

    set testName                "upload       "
    set resultStr               " "
    set testPassed              0
    set prevload                0
    set presload                0

#    log "LOGGING ON TO DUT\n"
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr ;#clearout the buffer

    # make sure it is ready to rcv command
    send "\r"
    expect $dutPromptStr

    #send "/usr/local/etc/savari/ipv6app stop\r"
    #expect  $dutPromptStr

    #send "/usr/local/bin/savari/ipv6app start\r"
    #expect  $dutPromptStr

    sleep 5
    send "rse_stats -u\r"
    expect {
        -re "Uploaded Files               : (\[0-9]+)" {
set prevload $expect_out(1,string)

        }
          "$dutPromptStr" {
        }
    }


   sleep 300
   send "rse_stats -u\r"
   sleep 5
expect {
       -re "Uploaded Files               : (\[0-9]+)" {
       set presload $expect_out(1,string)

       }
         "$dutPromptStr" {
       }
   }


    set uploadCount [ expr $presload - $prevload ]
puts "$uploadCount"
if { $uploadCount == 0 } {
append resultStr "upload  is not functional."
        set testPassed 0
    } else {
    log  "upload is functional."
    set testPassed 1
    }

    if { $testPassed == 1 } {
        set testFailed 0
    } else {
        set testFailed 1
    }

    return [list $testFailed $resultStr $uploadCount]

}

############DSRCforward##################################
proc dsrcfwdTransmit { dutSpawnId } {

    global spawn_id
    global dutPromptStr

    set testName                "DsrcForward Transmission       "
    set resultStr               " "
    set testPassed              0
    set prevdsrcfwd1                 0
    set presdsrcfwd1                 0
    set prevdsrcfwd2                 0
    set presdsrcfwd2                 0

#    log "LOGGING ON TO DUT\n"
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr ;#clearout the buffer

    # make sure it is ready to rcv command
    send "\r"
    expect $dutPromptStr

    sleep 5
    send "rse_stats -D\r"
    expect {
        -re "0x8000    	 (\[0-9]+)" {
        set prevdsrcfwd1 $expect_out(1,string)

        }
          "$dutPromptStr" {
        }
    }


   sleep 10
   send "rse_stats -D\r"
   sleep 5
   expect {
       -re "0x8000    	(\[0-9]+)" {
set presdsrcfwd1 $expect_out(1,string)

       }
         "$dutPromptStr" {
       }
   }


    set dsrcfwdCount1 [ expr $presdsrcfwd1 - $prevdsrcfwd1 ]
    puts "$dsrcfwdCount1"

sleep 5
    send "rse_stats -D\r"
    expect {
        -re "0x8000      (\[0-9]+)" {
        set prevdsrcfwd2 $expect_out(1,string)

        }
          "$dutPromptStr" {
        }
    }


   sleep 10
   send "rse_stats -D\r"
   sleep 5
   expect {
       -re "0x8000      (\[0-9]+)" {
set presdsrcfwd2 $expect_out(1,string)

       }
         "$dutPromptStr" {
       }
   }


    set dsrcfwdCount2 [ expr $presdsrcfwd2 - $prevdsrcfwd2 ]
    puts "$dsrcfwdCount2"

set dsrcfwdCount [ expr $dsrcfwdCount2 - $dsrcfwdCount1 ]
puts "$dsrcfwdCount"
if { $dsrcfwdCount == 0 } {
append resultStr "dsrcforward  is not functional."
        set testPassed 0
    } else {
    log  "dsrcforward is functional."
    set testPassed 1
    }

    if { $testPassed == 1 } {
        set testFailed 0
    } else {
        set testFailed 1
    }


 return [list $testFailed $resultStr $dsrcfwdCount]

}

# does firmware upgrade. logs into the box after the upgrade
#
# Inputs:
# boxip => ip address of box to be upgraded
# boxUsername =>  username into the box to be upgraded
# boxPassword => password into the box to be upgraded
# boxSpawnId =>  spawn id of box to be upgraded
# boxPromptStr => prompt string of box to be upgraded
# scpSpawnId => spawn id of the box where scp is being executed
# scpPromptStr => prompt str of  the box where scp is being executed
# scpPreImageFilePath => file path in the box where scp is being executed
# returns:
#  #   in case of success
#         status code, promptStr, spawnId
#   in case of error,
#       status code, string contains error string
proc fwUpgrade { boxIp boxUsername hostPassword dutSpawnId dutPromptStr scpSpawnId scpPromptStr scpPreImageFilePath preImageUpgradeCleanConfig } {
    global  spawn_id closeSpawnIdSecs ignoreTrap fwUpgradeWaitSecs fwUpgradeFSWaitSecs rebootWaitFSAfterUpgradeSecs rebootWaitAfterUpgradeSecs preImageFile dutBoxIp boxPassword

#    set preImageFile [lindex [split $scpPreImageFilePath '/' ] end]
    set sysUpgradeFlags "-c"
    if { $preImageUpgradeCleanConfig == 1 } {
	# cleans the config
	set sysUpgradeFlags ""
    }

    set ret [scpFile $boxIp $boxUsername $hostPassword $scpPreImageFilePath $scpSpawnId $scpPromptStr $preImageFile 1 "/tmp"]	
    puts "$ret"
    if { [lindex $ret 0] != 0 } {
	return $ret
    }

    set spawn_id $dutSpawnId
    clearExpectBuf "$dutPromptStr"
    # need to move to tmp directory for sysupgrade
    send "cd /tmp\r"
    log "prompt: $dutPromptStr"
    expect "$dutPromptStr"
    send "sysupgrade $sysUpgradeFlags $preImageFile &\r"
    expect "$dutPromptStr"
    # fail safe image takes more time 
    if { [string first "FS" $dutPromptStr] != -1 } {
	set waitSecs $fwUpgradeFSWaitSecs
	set postRebootWaitSecs $rebootWaitFSAfterUpgradeSecs
    } else {
	set waitSecs $fwUpgradeWaitSecs
	set postRebootWaitSecs $rebootWaitAfterUpgradeSecs
    }

    log "waiting for upgrade to complete in $fwUpgradeWaitSecs seconds from [clock format [clock seconds]]"

   sleep $fwUpgradeWaitSecs
    close -i $spawn_id
    set ignoreTrap 0

    # Login to box after reboot
    set ret [login_to_box $dutBoxIp $boxPassword]
	if { [lindex $ret 0] != 0 } {
       	set dutOff 1
    	} else {
       	set dutOff 0
    	}
    if { $dutOff == 0} {
    set dutPromptStr [lindex $ret 1]
    set dutSpawnId   [lindex $ret 2]
    clearExpectBuf $dutPromptStr
   # set spawn_id $dutSpawnId
    clearExpectBuf "$dutPromptStr" 
#clearout the buffer 
  return $ret
}
}


# shows the status


proc status_1 { dutSpawnId } {

    global spawn_id
    global dutPromptStr

    set testName                "status_1       "
    set resultStr               " "
    set testPassed              0
     

#    log "LOGGING ON TO DUT\n"
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr ;#clearout the buffer

    # make sure it is ready to rcv command
    send "\r"
    expect $dutPromptStr
    

    send "rm 1.txt\r"
    expect $dutPromptStr

    send "date >> 1.txt\r"
    expect $dutPromptStr

    send "show app_status >> 1.txt\r"
    expect $dutPromptStr
    
    send " >> 1.txt\r"
    expect $dutPromptStr
    
    send "rse_stats -b >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -b >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr

    send "rse_stats -t >> 1.txt\r"
    expect $dutPromptStr
 
    send "rse_uptime -T >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr

    send "rse_stats -d >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -d >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr

    send "rse_stats -s >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -M >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr

    send "rse_stats -i >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -i >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr
    
    send "rse_stats -w >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -w >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr
    
    send "rse_stats -u >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr

    send "rse_stats -D >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -D >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr

    send "echo GPSD >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -g >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr

    send "echo smgrd >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -$ >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr

    send "echo sdiskmgr >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -@ >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr    

    send "echo cycurv2x.bin >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -c >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr
    
    send "echo savari16093d-ath0 >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -s >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr

    send "echo savari16093d-ath1 >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -S >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr

    send "echo heartbeat >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -H >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr

    send "echo TCd >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -t >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr
    
    send "echo Sinit >> 1.txt\r"
    expect $dutPromptStr

    send "rse_uptime -G >> 1.txt\r"
    expect $dutPromptStr

    send " >> 1.txt\r"
    expect $dutPromptStr

    

    append resultStr "status test"
    log  "status:"
    set testPassed 1
    
    if { $testPassed == 1 } {
        set testFailed 0
    } else {
        set testFailed 1
    }

    return [list $testFailed $resultStr]

}



# reboots the box
# Inputs:
#   msg => reboot msg
#   promptStr 
#   boxIp
#   spawnId
#   seconds to wait after reboot for box to be up.
#   whether to check whether running image(failsafe or primary) is same (pre and post reboot).
#   boxIsRsu => whether box is Rsu                    
# Returns:
#   in case of error, string contains error string
#   in case of success
#         status code, promptStr, spawnId
#  
proc rebootBox { msg promptStr boxIp spawnId rebootTimeSecs  doImageCheck boxIsRsu } {

    global spawn_id boxPassword 

    set spawn_id $spawnId
    clearExpectBuf $promptStr

    log $msg
    if { $doImageCheck != 0 && $boxIsRsu == 1 } {
	if {  [string first "FS" $promptStr]  == -1 } {
	    send "flash_update.sh -c 0 -t 1\r"
	} else {
	    send "flash_update.sh -c 4 -t 1\r"
	}
	expect -timeout 5 $promptStr
    }

    #close -i $spawn_id ;
    #close the session
    #sleep 5
    send "reboot -d 5 &\r"
    #send "reboot &\r"
    expect $promptStr
    log "Wait for box to reboot for  $rebootTimeSecs secs from: [clock format [clock seconds]]"
    sleep $rebootTimeSecs


    # Login to box after reboot
    set ret  [login_to_box $boxIp $boxPassword]
    if { [lindex $ret 0] != 0 } {
	return $ret
    }

    # verify box is booted with upgraded image if asked
    if { $doImageCheck != 0 } {
	set promptStr1 [lindex $ret 1]    
	if { ( [string first "FS" $promptStr]  == -1  && [string first "FS" $promptStr1] != -1 ) ||
	     ([string first "FS" $promptStr]  != -1  && [string first "FS" $promptStr1] == -1  ) } {
	    return [list 1 "box booted in incorrect image post reboot"]
	}
    }
    return $ret

}



# kills Process on the machine referred by.
#  Caller has to set the spawn id of the machine 
#  Inputs:
#   promptStr    => promptStr
#   processNameList => list of process names
#   waitSecs        => seconds to wait before verifiying
#                      process is not running
# Returns
#  list of error code and error string if any
proc killProcess { promptStr processNameList waitSecs } {


    foreach processName  $processNameList {
	send "killall -2 $processName\r"
	expect {

	    "$promptStr" {
	    }
	}
    }
    
    if { $waitSecs > 0 } {
	log "sleep for $waitSecs seconds for cleanup of $processNameList"
	sleep $waitSecs
    }

    # Adding this temporarily as an workaround for dsrc issue -
    # sreeni is going to add the actual fix - TUHIN
    send "\r\r"
    expect $promptStr
   
    # now verify the process is not running
    foreach processName  $processNameList {
	
	# exclude grep processes
	send "ps | grep $processName | grep -v grep\r"
	expect "grep $processName"
	expect {
	    "$processName" {
		return [list 1 "unable to kill $processName"]
	    }

	    "$promptStr" {
		# ok case
	    }
	}
       
    }

    return [list 0 ""]
}


# pingTest: runs the ping test for requested number of pkts and
# inputs:
# durIntf - interface we are testing on DUR
# dutIntf - interface we are testing on DUT
# chan - channel if any otherwise supply 0
# essid - essid if any otherwise supply null string
# numPkts - to run ping for this many pkts
# durIntfIp - interface address on dur
# dutIntfIp - interface address on dut
# durSpawnId - spawn id on  dur
# dutSpawnId - spawn id on dut
# 
# returns:
#  number of pkts received as 3 arg in the list

proc pingTest { durIntf dutIntf chan essid numPkts durIntfIp dutIntfIp durSpawnId dutSpawnId } {
    global dutPromptStr durPromptStr spawn_id
    global dsrcIntfName wifiChanSwitchSecs

    log "\n\n"
    log "LOGGING ON TO DUR\n"
    #do the necessary stuff on DUR
    set spawn_id $durSpawnId
    clearExpectBuf $durPromptStr ;#clearout the buffer
#    send "halt \r"
#    expect "$durPromptStr"
#    send "/etc/init.d/TimApp stop \r"
#    expect "$durPromptStr"
#    send "/etc/init.d/ipv6app stop \r"
#    expect "$durPromptStr"
    send "iwconfig $durIntf\r"
    expect {
        "No such device" {
            return [list 1 "ERR: $durIntf not found DUR" "DSRC Ping" 0]
        }

        "$durPromptStr" {
        }
    }

    if { $essid != "" } {
        send "iwconfig $durIntf essid $essid\r"
        expect {
            "Invalid argument." {
                return [list 1 "ERR: unable to set the essid  on $durIntf on DUR" 0 ]
            }
            "$durPromptStr" {
            }
        }
    }

    # set the channel and ESSID if non zero passed in
    if { $chan != "" } {
        send "iwconfig $durIntf channel $chan\r"
                                                                                                                            
expect {
            "Invalid argument." {
                return [list 1 "ERR: unable to set the channel on $durIntf on DUR" 0 ]
            }
            "$durPromptStr" {
            }
        }
    }

    if { $durIntfIp == "" } {
        send "ifconfig $durIntf\r"
        expect {

            -re "inet addr:(\[0-9]+\.\[0-9]+\.\[0-9]+\.\[0-9]+) " {
                set durIntfIp $expect_out(1,string)
            }

            timeout {
                return [list 1 "unable to get ipaddress of $durIntf on DUR"]
            }
        }
        expect "$durPromptStr"

    } else {
        # set the ip address
        send "ifconfig $durIntf $durIntfIp netmask 255.255.255.0\r"
        expect "$durPromptStr"
    }

    # do the processing on DUT now
    log "\n\n"
    log "LOGGING ON TO DUT\n"
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr ;#clearout the buffer
 #   send "/etc/init.d/TimApp stop \r"
 #   expect "$dutPromptStr"
 #   send "/etc/init.d/ipv6app stop\r"
 #   expect "$dutPromptStr"
 #   send "halt \r"
 #   expect "$dutPromptStr"  
    send "iwconfig $dutIntf\r"
    expect {
        "No such device" {
                                                                                                                            
     return [list 1 "ERR: $dutIntf not found DUT" 0]
        }

        "$dutPromptStr" {
        }

    }

    if { $essid != "" } {
        send "iwconfig $dutIntf essid $essid\r"
        expect {
            "Invalid argument." {
                return [list 1 "ERR: unable to set the essid  on $dutIntf on DUT" 0 ]
            }
            "$dutPromptStr" {
            }
        }
    }

    # set the channel and ESSID if non zero passed in
    if { $chan != "" } {

        send "iwconfig $dutIntf channel $chan\r"
        expect {
            "Invalid argument." {
                return [list 1 "ERR: unable to set the channel on $dutIntf on DUT" 0 ]
            }
            "$dutPromptStr" {
            }
        }

   }

    if { $dutIntfIp == "" } {
        send "ifconfig $dutIntf\r"
        expect {
                -re "inet addr:(\[0-9]+\.\[0-9]+\.\[0-9]+\.\[0-9]+) " {
                set dutIntfIp $expect_out(1,string)
            }

            timeout {
                return [list 1 "unable to get ipaddress of $dutIntf on DUT"]
            }
        }
        expect "$dutPromptStr"

    } else {
        # set the ip address
        send "ifconfig $dutIntf $dutIntfIp netmask 255.255.255.0\r"
        expect "$dutPromptStr"
    }


    #make sure ping is working before we ping asked number of pkts
    #otherwise we may experience long delay in case of ping not working
    send "ping -c 3 -q $durIntfIp\r"
    expect   {

        # SREENI NEED TO TAKE LOOK AT THIS. WHY 80SEC TIMEOUT
        -timeout 80

        -re "\(\[1-9]) packets received" {
            log "got packets"
        }

        "0 packets received" {
            return [list 1 "ERR: ping: 0 packets rcvd. no connectivity" 0]
        }
        timeout {
            return [list 1 "ERR: ping: expect timeout" 0]
        }
      
    }
expect "$dutPromptStr"

    set pingTimeoutSecs [expr $numPkts * 4]
    # now run  regular ping test and return the pkts rcvd
    send "ping -c $numPkts -q $durIntfIp\r"
    expect    {
         -timeout $pingTimeoutSecs

        -re "\(\[0-9]*) packets received" {
#           return [list 0 "ping tx=$numPkts,rx=$expect_out(1,string)" $expect_out(1,string)]
           # return [list 0 "" "DSRC PING    "]
             return [list 0 "" ""]
        }

        timeout {
            return [list 1 "ERR: ping: expect timeout" 0]

        }
    }
    expect  "$dutPromptStr"
    return [list 1 "ERR: badCase" 0] ;# should never come here
}


proc eth_pingTest { dutBoxMacIntfName  pingNumPkts durBoxIp dutBoxIp durSpawnId dutSpawnId } {
    global dutPromptStr durPromptStr spawn_id 
    global dsrcIntfName  

    log "\n\n"
    log "LOGGING ON TO DUR\n"
    #do the necessary stuff on DUR
    set spawn_id $durSpawnId
    clearExpectBuf $durPromptStr ;#clearout the buffer

    set pingTimeoutSecs [expr $pingNumPkts * 4]
    # now run  regular ping test and return the pkts rcvd
    send "ping -c $pingNumPkts -q $dutBoxIp\r"
    expect    {
	 -timeout 80

	-re "\(\[0-9]*) received" {
            return [list 0 "" "Ethernet     "]
	}
	timeout {
	    return [list 1 "ERR: ping: expect timeout" 0]

	}
    }
    expect  "$dutPromptStr"

    return [list 1 "ERR: badCase" 0 ]
    #return [list $isError $retStr "PPS"]

}


# runs the iperf test
# parameter description:
#  intf - interface to run on
#  chan - chan to run on. If 0 is passed, it is ignored.
#  transferSpeed - size of iperf transfer in Meg
#  duration - duration to run
#  speedMbitExpected - speed expected
#  dutIntfIp - ip address of intf on DUT (iperf client)
#  durIntfIp - ip address of intf on DUR (iperf server)
#  dutSpawnId - spawn id of ssh session to DUT(iperf client)
#  durSpawnId - spawn id of ssh session to DUR(iperf server)
# 
#  RETURNS:
#    returns dut->ref throughput in mbits/sec as 3rd arg in the list

proc iperfTest { durIntf dutIntf chan transferSpeed duration speedMbitsExpected durIntfIp dutIntfIp durSpawnId dutSpawnId } {
    global spawn_id durPromptStr dutPromptStr dsrcChan

    set resultStr ""
    set testName "DSRC Iperf     "


    set dut2RefSpeedMbits 0
    set ref2DutSpeedMbits 0
    set testPassed 0


#    log "\n\n"
#    log "LOGGING ON TO DUR\n"
    set spawn_id $durSpawnId
    clearExpectBuf $durPromptStr ;#clearout the buffer

    # make sure it is ready to rcv command
    send "\r"  
    expect  "$durPromptStr"
# HALT

#   send "halt \r"
#   expect "$durPromptStr"
#    send "/etc/init.d/TimApp stop\r"
#   expect "$durPromptStr"
#    send "/etc/init.d/ipv6app stop\r"
#    expect "$durPromptStr"
    #set the channel on the interface
    if { $chan != "" } {
	send "iwconfig $durIntf channel $chan\r"
	expect {
	    "Invalid argument." {
		return [list 1 "unable to set the channel on $durIntf on refBox" 0 0]
	    }
	    "$durPromptStr" {
		# success case
	    }
	}
    }

    if { $durIntfIp == "" } {
	send "ifconfig $durIntf\r"
	expect {
	    -re "inet addr:(\[0-9]+\.\[0-9]+\.\[0-9]+\.\[0-9]+) " {
		set durIntfIp $expect_out(1,string)
	    }
	    
	    timeout {
		return [list 1 "unable to get ipaddress of $intf on DUR"]
	    }
	}
	expect "$durPromptStr"
    } else {
	#set the ip address of interface
	send "ifconfig $durIntf $durIntfIp netmask 255.255.255.0\r"
	expect  "$durPromptStr"
    }
   # stop firewall
    send "/etc/init.d/firewall stop \r"
    expect  "$durPromptStr"

  # stop all applications
#    send "halt \r"
#    expect "$durPromptStr"

    # start iperf server
    send "killall -9 iperf\r"
    expect "$durPromptStr"
    send "iperf -s -u 1> /tmp/iperfout 2> /tmp/iperfout &\r"
    expect "$durPromptStr"


 #   log "\n\n"
  #  log "LOGGING ON TO DUT\n"

    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr ;#clearout the buffer

    # make sure it is ready to rcv command
    send "\r"  
    expect  "$dutPromptStr"
    # halt
#    send "halt \r"
#    expect "$dutPromptStr"
#    send "/etc/init.d/TimApp stop\r"
#   expect "$dutPromptStr"
#    send "/etc/init.d/ipv6app stop\r"
#   expect "$dutPromptStr"
    #set the channel on the interface
    if { $chan != "" } {
	send "iwconfig $dutIntf channel $chan\r"

	expect {
	    "Invalid argument." {
		return [list 1 "ERR: unable to set the channel on $dutIntf on testBox" 0 0]
	    }

	    "$dutPromptStr" {
		# success case
	    }
	}
    }

    if { $dutIntfIp == "" } {
	send "ifconfig $dutIntf\r"
	expect {
	    -re "inet addr:(\[0-9]+\.\[0-9]+\.\[0-9]+\.\[0-9]+) " {
		set dutIntfIp $expect_out(1,string)
	    }
	    
	    timeout {
		return [list 1 "unable to get ipaddress of $dutIntf on DUT"]
	    }
	}
	expect "$dutPromptStr"

    } else {
	#set the ip address of interface
	send "ifconfig $dutIntf $dutIntfIp netmask 255.255.255.0\r"
	expect  "$dutPromptStr"
    }
    # stop the firewall
    send "/etc/init.d/firewall stop \r"
    expect  "$dutPromptStr"

    # stop all applications
#    send "halt \r"
#    expect "$dutPromptStr"
  
    # start the iperf session
    send "killall -9 iperf\r"
    expect "$dutPromptStr"
    send "iperf -c $durIntfIp -u -b ${transferSpeed}M -t $duration -r & \r"
    expect {
	
	#depending upon transfer size set the timeout value
	-timeout [expr $duration * 2 + 5] 

	"Connection refused" {
	    return [list 1 "ERR: iperf not running on reference box" 0 0]
	}

	
	"WARNING: did not receive ack of" {
            return [list 1 "ERR: cannot communicate with reference box" "DSCRC Iperf"  0 0]
        }

	"Server Report:" {
	    
	    expect -re "\(\[0-9]*\.?\[0-9]*) (\[KM]?Bytes)"
            # append resultStr "\t\tdut->ref: bytes=$expect_out(0,string)"
            expect -re "\(\[0-9]*\.?\[0-9]*) (\[KM]?)bits/sec"
            # append resultStr ", speed=$expect_out(0,string)\n"
	    set dut2RefSpeedMbits $expect_out(1,string)
	    # if we are getting low thruoghput, speed may be in KBITS/SEC or even bits/sec
	    set speedUnits $expect_out(2,string)
            expect -re " \(.*ms) (.*%\[\)])"
	    # append resultStr "\t\tdut->ref: jitter=$expect_out(1,string), loss=$expect_out(2,string)\n"
            # Check throughput
            if { $speedMbitsExpected != 0  && ( $speedUnits != "M"  ||   $dut2RefSpeedMbits < $speedMbitsExpected ) } {
	    append resultStr "ERR: dut->ref throughput is below $speedMbitsExpected Mbits\n"
            } else {
	    	set testPassed 1
	    }


	    expect { 
		# wait for 20 seconds for reverse direction to show up
		# as we have seen in our testing it takes some time to come up
		-timeout 5

		"local $dutIntfIp port 5001 connected" {
		    expect { 
			-timeout [expr $duration * 2 + 5] 

			timeout {
			    return [list 1 "timeout waiting for iperf results"]
			}

			-re "\(\[0-9]*\.?\[0-9]*) (\[KM]?Bytes)" {
			    append resultStr ""
			}
		    }
		    #expect -re "\(\[0-9]*\.?\[0-9]*) (\[KM]?)bits/sec"
		    # append resultStr ", speed=$expect_out(0,string)\n"
		    #set ref2DutSpeedMbits $expect_out(1,string)
		    # if we are getting low thruoghput, speed may be in KBITS/SEC or even bits/sec
		    #set speedUnits $expect_out(2,string)
		    #expect -re " \(.*ms) (.*%\[\)])"
		    # append resultStr "\t\tref->dut: jitter=$expect_out(1,string), loss=$expect_out(2,string)\n"
		    # Check throughput 
                    #if { $speedMbitsExpected != 0 &&  ( $speedUnits != "M" || $ref2DutSpeedMbits < $speedMbitsExpected ) } {
			# append resultStr "\t\tERR: ref->dut throughput is below $speedMbitsExpected Mbits\n"
		   #	set testPassed 0
		   # } else {
			if { $testPassed == 1 } {
			    set testPassed 1
			}
		   # }
		}
		timeout {
		    set testPassed 0
		    append resultStr "\t\tERR: Odd! Timeout waiting for ref->dut iperf output\n"
		}
	    }
        }

	timeout {
	    append resultStr "ERR: timeout waiting for dut->ref iperf server report"
	}

    }

#    Start the Firewall in DUT
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr ;#clearout the buffer

  #  send "run \r"
  #  expect "$durPromptStr"
#   send "/etc/init.d/TimApp start \r"
#    expect "$dutPromptStr"
#    send "/etc/init.d/ipv6app start \r"
#    expect "$dutPromptStr"
    send "/etc/init.d/firewall start \r"
    expect  "$dutPromptStr"

    
#    Start the Firewall in DUR
    set spawn_id $durSpawnId
    clearExpectBuf $durPromptStr ;#clearout the buffer
   # send "run \r"
   # expect "$dutPromptStr"
#    send "/etc/init.d/TimApp start \r"
#    expect "$durPromptStr"
#    send "/etc/init.d/ipv6app start \r"
#    expect "$durPromptStr"
    send "/etc/init.d/firewall start \r"
    expect  "$durPromptStr"

    if { $testPassed == 1 } {
	set testFailed 0
    } else {
	set testFailed 1
    }
     return [list $testFailed $resultStr $dut2RefSpeedMbits]
}



proc eth_iperfTest { dutIntf durIntf transferSpeed duration speedMbitsExpected dutIntfIp durIntfIp durSpawnId dutSpawnId } {
    global spawn_id durPromptStr dutPromptStr 

    set resultStr ""
    set testName "Ethernetiperf      "
    set testPassed 0
    set dut2RefSpeedMbits 0
    set ref2DutSpeedMbits 0

    set spawn_id $durSpawnId
    clearExpectBuf $durPromptStr ;#clearout the buffer

    send "/etc/init.d/firewall stop \r"  
    expect  "$durPromptStr"

    send "killall -9 iperf\r"
    expect "$durPromptStr"
    send "iperf -s -u 1 > /tmp/iperfout 2> /tmp/iperfout & \r"
    expect "$durPromptStr"


  #   log "\n\n"
  #  log "LOGGING ON TO DUT\n"

    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr ;#clearout the buffer

    send "/etc/init.d/firewall stop \r"  
    expect  "$dutPromptStr"


    # start the iperf session
    send "killall -9 iperf\r"
    expect "$dutPromptStr"
    send "iperf -c $durIntfIp -u -b ${transferSpeed}M -t $duration -r & \r"

 	expect {
	
	#depending upon transfer size set the timeout value
	-timeout [expr $duration * 2 + 5] 

	"Connection refused" {
	    return [list 1 "ERR: iperf not running on reference box" 0 0]
	}

	
	"WARNING: did not receive ack of" {
            return [list 1 "ERR: cannot communicate with reference box" "DSCRC Iperf"  0 0]
        }

	"Server Report:" {
	    
	    expect -re "\(\[0-9]*\.?\[0-9]*) (\[KM]?Bytes)"
         #    append resultStr "\t\tdut->ref: bytes=$expect_out(0,string)"
            expect -re "\(\[0-9]*\.?\[0-9]*) (\[KM]?)bits/sec"
         #    append resultStr ", speed=$expect_out(0,string)\n"
	    set dut2RefSpeedMbits $expect_out(1,string)
	    # if we are getting low thruoghput, speed may be in KBITS/SEC or even bits/sec
	    set speedUnits $expect_out(2,string)
            expect -re " \(.*ms) (.*%\[\)])"
	  #   append resultStr "\t\tdut->ref: jitter=$expect_out(1,string), loss=$expect_out(2,string)\n"
            # Check throughput
            if { $speedMbitsExpected != 0  && ( $speedUnits != "M"  ||   $dut2RefSpeedMbits < $speedMbitsExpected ) } {
	    	append resultStr "ERR: dut->ref throughput is below $speedMbitsExpected Mbits\n"
            } else {
	    	set testPassed 1
	    }


	    expect { 
		# wait for 20 seconds for reverse direction to show up
		# as we have seen in our testing it takes some time to come up
		-timeout 5

		"local $dutIntfIp port 5001 connected" {
		    expect { 
			-timeout [expr $duration * 2 + 5] 

			timeout {
			    return [list 1 "timeout waiting for iperf results"]
			}

			-re "\(\[0-9]*\.?\[0-9]*) (\[KM]?Bytes)" {
			    append resultStr ""
			}
		    }
		#     expect -re "\(\[0-9]*\.?\[0-9]*) (\[KM]?)bits/sec"
		#     append resultStr ", speed=$expect_out(0,string)\n"
		#     set ref2DutSpeedMbits $expect_out(1,string)
		#     if we are getting low thruoghput, speed may be in KBITS/SEC or even bits/sec
		#     set speedUnits $expect_out(2,string)
		#     expect -re " \(.*ms) (.*%\[\)])"
		#     append resultStr "\t\tref->dut: jitter=$expect_out(1,string), loss=$expect_out(2,string)\n"
		    # Check throughput 
                #     if { $speedMbitsExpected != 0 &&  ( $speedUnits != "M" || $ref2DutSpeedMbits < $speedMbitsExpected ) } {
		#    	append resultStr "\t\tERR: ref->dut throughput is below $speedMbitsExpected Mbits\n"
		#    	set testPassed 0
		#     } else {
		   	if { $testPassed == 1 } {
			    set testPassed 1
			}
	#	     }
		}
		timeout {
		    set testPassed 0
		    append resultStr "\t\tERR: Odd! Timeout waiting for ref->dut iperf output\n"
		}
	    }
        }

	timeout {
            set testPassed 0
	    append resultStr "ERR: timeout waiting for dut->ref iperf server report"
	}
    }

    
#    Start the Firewall in DUT


   set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr ;#clearout the buffer

    send "/etc/init.d/firewall start \r"
    expect  "$dutPromptStr"

#    Start the Firewall in DUR

    set spawn_id $durSpawnId
    clearExpectBuf $durPromptStr ;#clearout the buffer

    send "/etc/init.d/firewall start \r"
    expect  "$durPromptStr"



    if { $testPassed == 1 } {
	set testFailed 0
    } else {
	set testFailed 1
    }
     return [list $testFailed $resultStr $dut2RefSpeedMbits]
}


#  GPS for the 3d fix.
proc gps_check_fix { dutPromptStr dutSpawnId } {

    global gpsDevName spawn_id 

    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr 

    send "ls $gpsDevName \r"
    expect {

	"No such file or directory" {
	    return [list 1 "$gpsDevName does not exist"]
	}

	"$gpsDevName" {
	}
    }
    expect $dutPromptStr

    send "cat  $gpsDevName | grep GPG & \r"
    expect $dutPromptStr
    expect {
	"cannot open $gpsDevName: No such device" {
	    set isError 1
	    set retStr  "unable to open $gpsDevName"
	}
	"GPGGA" {
	    set isError 0
	}

	timeout {
	    set isError 1
	    set retStr "NEMA string GPGGA is not seen"
	}
    }
    
    send "killall -9 cat \r"
    expect $dutPromptStr
    if { $isError != 0 } {
	return [list $isError $retStr "GPS"]
    }

    send "cat $gpsDevName | grep GPGSA & \r"

    expect $dutPromptStr
    expect {
	# 10 seconds is good enough to get the status of fix
	-timeout 10
	
        "A,1"    {
	    set isError 1
           # set retStr  "Got 2D Fix. But not 3D fix"
             set retStr  "Got 2D Fix"
        }
        "A,2"    {
	    set isError 0
           # set retStr "Got 3D Fix w.o WAAS"
             set retStr  "Got 3D Fix w.o WAAS"

        }
        "A,3"    {
	    set isError 0
           # set retStr "Got 3D Fix with WAAS"
             set retStr  "Got 3D Fix with WAAS"

        }

        timeout {
	    set isError 1
	    set retStr "Could not get gps fix"
	}
    }
    send "killall -9 cat\r"
    expect $dutPromptStr

    if {$isError == 0} {
    send "hwclock --utc --systohc\r"
    # set the timouet to 10 as hwclock takes time
    expect -timeout 10  $dutPromptStr
    } 
    return [list $isError $retStr ]
}

# Verifies pps 
#  inputs -
#  dutSpawnId  - spawn id of dut session
#  dutPromtStr - Prompt string of dut
#  Returns   - list of status code and error string 
proc pps_check_fix { dutPromptStr dutSpawnId } {

    global spawn_id scpFileName
    set resultStr  ""
     

    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr 
    send "/usr/local/bin/ppstest\r"
    expect {
	"PPS not working" {
	    set isError 1
	    set resultStr "PPS not working"
	}
	"PPS is working" {
	    set isError 0
            log  "PPS is working"
	}
        "not found" {
	    set isError 1
            set resultStr "script not found"
	}
	timeout {
	    set isError 1
	    set resultStr "timeout:waiting for the script"
	}
    }

    return [list $isError $resultStr ]
}

# change lan interface ipaddr
##       inputs
# ndutBoxIp   - ipaddr need to change
#  dutSpawnId - spawn id of ssh session to DUT
#  dutPromptStr -dutbox prompt string 
#  Returns - list of status code and error string

proc lanconfig_set { dutPromptStr dutSpawnId ndutBoxIp } {

    global spawn_id 
    set resultStr  ""


    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr
#    send "cd /usr/local/bin\r"
    #send "tar -xvzf $scpFileName\r"
    send "/usr/local/bin/lanconfig $ndutBoxIp\r"
    sleep 10
    expect {
        "not able to set ip" {
            set isError 1
            set resultStr "Not able to set ipaddr"
        }
        "ipaddr is changed" {
            set isError 0
            log  "ipaddr is changed"
        }
        "not found" {
	    set isError 1
            set resultStr "script not found"
	}
        timeout {
            set isError 1
            set resultStr "timeout:waiting for the prompt"
        }
    }
    
return [list $isError $resultStr $ndutBoxIp]
}


## Gives CPU,nojournal and memory information
# Inputs
#  dutSpawnId - spawn id of ssh session to DUT(iperf client) 
#  dutPromptStr - prompt string of the dut box
#  Returns - list of status code and error string
proc system_check { dutPromptStr dutSpawnId } {

  global spawn_id  
    set resultStr  ""
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr
#    send "cd /usr/local/bin\r"
#    send "tar -xvzf $scpFileName\r"
    
    send "/usr/local/bin/usage \r"
    sleep 70    
    expect {
        "system is not working properly" {
            set isError 1
            append resultStr "System is not working properly"
        }
       -re "Nojournal                                 :\[0-9]*%" {
            set isError 0
            log  "system is working"
            set desired $expect_out(buffer)
	    set index [string last "\n" $desired]
            set resultStr [string range $desired 262 $index]
            append resultStr $expect_out(0,string)
	}
        "not found" {
	    set isError 1
            set resultStr "script not found"
	}
        timeout {
            set isError 1
            set resultStr "timeout:waiting for prompt"
        }
}
 return [list $isError $resultStr ]
}

###################### timapp ##########################

proc timTransmit { dutSpawnId } {

    global spawn_id
    global dutPromptStr

    set testName                "TimApp       "
    set resultStr               " "
    set testPassed              0
    set prevtim                 0
    set prestim                 0

#    log "LOGGING ON TO DUT\n"
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr ;#clearout the buffer

    # make sure it is ready to rcv command
    send "\r"
    expect $dutPromptStr

    sleep 5
    send "rse_stats -t\r"
    expect {
        -re "Tx Packet                : (\[0-9]+)" {
        set prevtim $expect_out(1,string)

        }
          "$dutPromptStr" {
        }
    }


   sleep 5
   send "rse_stats -t\r"
   sleep 5
   expect {
       -re "Tx Packet                : (\[0-9]+)" {
       set prestim $expect_out(1,string)
       }
         "$dutPromptStr" {
       }
   }


    set timCount [ expr $prestim - $prevtim ]
puts "$timCount"
if { $timCount == 0 } {
append resultStr "tim  is not functional."
        set testPassed 0
    } else {
    log  "tim is functional."
    set testPassed 1
    }

    if { $testPassed == 1 } {
        set testFailed 0
    } else {
        set testFailed 1
    }


 return [list $testFailed $resultStr $timCount]

}

### Checks Dsrcproxy application status
# Returns 
# error code and resultStr
 
proc dsrcproxy_check { dutPromptStr dutSpawnId durPromptStr durSpawnId } {

  global spawn_id scpFileName durBoxIp boxPassword 
    set resultStr  ""
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr
#send "/usr/local/bin/savari/dsrcproxy stop\r"
#expect $dutPromptStr
#    set spawn_id $durSpawnId
#    clearExpectBuf $durPromptStr
#    send "/etc/init.d/SpatMapApp stop\r"
#    expect $durPromptStr
#    send "/etc/init.d/SpatMapApp start\r"
#    expect $durPromptStr
#    set spawn_id $dutSpawnId
#    clearExpectBuf $dutPromptStr
#    send "\r"
#    expect $dutPromptStr
     send "ifconfig ath1 \r"
     expect {
           -re " TX packets:(\[0-9]+) " {
                                        set previousspatmap $expect_out(1,string)
                                        puts "$previousspatmap"
           } "Invalid command" {
                return [list 1 "Unable to get received WSM count in reference board"]
            } -timeout 5 {
                 return [list 1 "unable to get received WSM count of $dsrcIntfName on DUT"]
            }
       "$dutPromptStr" {
               }
 }
    send "/etc/init.d/dsrcproxy start\r" 
    expect $dutPromptStr
    sleep 60
#    send "rse_stats -d\r"

#    expect {
#        "dsrcproxy is not working properly" {
#            set isError 1
#            append resultStr "dsrcproxy is not working properly"
#        }
#     -re "Num Failure Config: \[0-9]*" {
#            set isError 0
#            log  "dsrcproxy is working"
#            set desired $expect_out(buffer)
#            set index [string last "\n" $desired]
#            set resultStr [string range $desired 31 $index] 
#            append resultStr "\t$expect_out(0,string)"
#       }
#       "not found" {
#	    set isError 1
#	    set resultStr "script not found"
#	}
#        timeout {
#            set isError 1
#            append resultStr "timeout :waiting for prompt"
#        }
#}
send "/etc/init.d/dsrcproxy stop\r"
expect $dutPromptStr
send "ifconfig ath1 \r"
    expect {
           -re " TX packets:(\[0-9]+) " {
                                        set presentspatmap $expect_out(1,string)
                                        puts "$presentspatmap"
           } "Invalid command" {
                return [list 1 "Unable to get received WSM count in reference board"]
            } -timeout 5 {
                 return [list 1 "unable to get received WSM count of $dsrcIntfName on DUT"]
            }
       "$dutPromptStr" {
               }
 }

#set ret [login_to_box $durBoxIp $boxPassword]
#    set $durPromptStr [lindex $ret 1]
#    set $durSpawnId [lindex $ret 2]
  # puts "$durSpawnId"
#    set spawn_id $durSpawnId
#    clearExpectBuf $durPromptStr
#    send "asd_stats -s\r"
  # puts "$expect_out(buffer)"
#    sleep 1
#    expect {
#        "Verification Failure :   \[0-9]*" {
#              set desir $expect_out(buffer)
#              set index [string last "\n" $desir]
#              puts "$index"
#              append resultStr "\nASD"
#              append resultStr [string range $desir 16 [expr "$index" + "99"]]
             # append resultStr "$expect_out(0,string)"       
#         }
#        "not found" {
#                append resultStr "not found"
#        }
#       }
set dsrctxCount [ expr $presentspatmap - $previousspatmap ]
if { $dsrctxCount == 0 } {
 append resultStr "DsrcproxyApp is not running"
 set testPassed 0
} else {
  log "dsrcproxyApp is running"
  set testPassed 1
}
if { $testPassed == 1 } {
        set testFailed 0
    } else {
        set testFailed 1
    }
puts "$dsrctxCount  $resultStr"
   
return [list $testFailed $resultStr $dsrctxCount]
}

### Monitors lookup script
# Returns
# error status and resultStr
proc lookup_check { dutPromptStr dutSpawnId } {

  global spawn_id scpFileName
    set resultStr  ""
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr

    send "/usr/local/bin/lookupscript\r"
    sleep 220

    expect {
        "Monitord is not running Gpsd is not running" {
            set isError 1
            append resultStr "Monitord/gpsd is not running"
        }
        "Monitord is not running Gpsd is running" {
            set isError 1
            append resultStr "Monitord/gpsd is not running"
        }
        "Monitord is running Gpsd is not running" {
            set isError 1
            append resultStr "Monitord/gpsd is not running"
        }

       "Monitord is running Gpsd is running" {
            set isError 0
            log  "Monitord/Gpsd is running"
            set resultStr $expect_out(buffer)
        }
        "not found" {
            set isError 1
   	    set resultstr "script not found"
	}
        timeout {
            set isError 1
            set resultStr "timeout:waiting for prompt"
        }
}
 return [list $isError $resultStr ]
}

### To check heartbeat status and file upload status
# Inputs
# dutPromptStr  - Promptstr for dut
# Returns 
# error status and resultString

proc monitord_check { dutPromptStr dutSpawnId } {

  global spawn_id scpFileName
    set resultStr  ""
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr

    send "/usr/local/bin/monitord\r"
    sleep 60
    expect {
        "monitord is not working properly" {
            set isError 1
            append resultStr "monitord is not working properly"
        }
     -re "Disk Usage                : \[0-9]+" {
            set isError 0
            log  "Monitord is running"
            set desired $expect_out(buffer)
            set index [string last "\n" $desired]
	    set resultStr [string range $desired 41 $index]
            append resultStr "\t $expect_out(0,string)"
        }
        "not found" {
	    set isError 1
   	    set resultStr "Script not found"
	}
        timeout {
            set isError 1
            append resultStr "timeout:waiting for Monitord"
        }
}
 return [list $isError $resultStr ]
}

######### Pscommand output ####################
### Inputs
# dutPromptStr  - promptstring for dut 
# Returns 
# error status and resultStr

proc pscommand_check { dutPromptStr dutSpawnId } {

  global spawn_id scpFileName
    set resultStr  ""
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr

    send "/usr/local/bin/pscommand\r"
    sleep 30
    expect {
        "not match" {
            set isError 1
#	    set desired $expect_out(buffer)
#            set index [string last "\n" $desired]
# 	     set resultStr [string range $desired 43 $index]
	    set resultStr "not match"
	 }
        "match" {
            set isError 0
            log  "processess are running properly"
        }
        "not found" {
            set isError 1
            set resultStr "Script not found"
        }
        timeout {
            set isError 1
            append resultStr "timeout:waiting for pscommand"
        }
}
 return [list $isError $resultStr ]
}

######### haltandrun ps output ####################
# Checking applications status in halt state 
# Returns 
# error status and resultStr

proc haltrun_check { dutPromptStr dutSpawnId } {

  global spawn_id scpFileName
    set resultStr  ""
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr

    send "/usr/local/bin/haltrun\r"
    sleep 60
    expect {
        "some processes in halt state are not matching" {
            set isError 1
            set desired $expect_out(buffer)
            puts "$desired"
            set index [string last "\n" $desired]
            puts "$index"
            set resultStr [string range $desired 664 $index]
            puts "$resultStr"
         }
        "all preocesses in halt state are matched" {
            set isError 0
            log  "processess are running properly"
        }
        "not found" {
            set isError 1
            set resultStr "Script not found"
        }
        timeout {
            set isError 1
            append resultStr "timeout:waiting for the commamd"
        }
}
 return [list $isError $resultStr ]
}

## To set and get txpower
#  Inputs
#  dutSpawnId - spawn id of ssh session to DUT(iperf client)
#  txpow - values to set
#  dutPromptStr - Prompt string of the dut box  
#  Returns - list of status code and error string

proc txpower_set { dutPromptStr dutSpawnId txpow } {

    global spawn_id scpFileName
    set resultStr  ""
    set isError ""
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr
    send "/usr/local/bin/test_txpower $txpow \r"
    expect {
        "txpower is not set" {
            set isError 1
            set resultStr "$txpow"
        }
        "txpower is set" {
            set isError 0
            log  "txpower is set"
	    set resultStr "$txpow"
        }
        "not found" {
	    set isError 1
 	    set resultStr "Script not found"
	}
        timeout {
            set isError 1
            set resultStr "timeout:waiting for the script"
        }
    }
    
     return [list $isError $resultStr ]
}

##    To set and get datarate
#    Inputs
#  dutSpawnId - spawn id of ssh session to DUT(iperf client)
#  data - datarate values
#  dutPromptStr - Prompt string of dut box
# Returns - list of status code and error string

proc datarate_set { dutPromptStr dutSpawnId data } {

    global spawn_id scpFileName
    set resultStr ""
    set isError ""
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr
    send "/usr/local/bin/test_datarate $data\r"
    expect {
        "datarate is not set" {
            set isError 1
            set resultStr "$data"
        }
        "datarate is set" {
            set isError 0
	    log  "datarate is set"
            set resultStr "$data"
        }

        "not found" {
            set isError 1
            set resultStr "Script not found"
	}
        timeout {
            set isError 1
            set resultStr "timeout:waiting for the script"
        }
    }

    return [list $isError $resultStr ]
}

### To set and get channel
# Inputs
#  dutSpawnId - spawn id of ssh session to DUT(iperf client)
#  chanNo - channel number to set
#  dutPromptStr - Prompt strig of dut box
#  Returns - list of status code and error string

proc channel_set { dutPromptStr dutSpawnId chanNo } {

    global spawn_id scpFileName  
    set resultStr  ""
    set isError ""
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr
    
 #   send "cd /usr/local/bin\r"
 #   send "tar -xvzf $scpFileName\r"
    
    send "/usr/local/bin/test_channel $chanNo\r"
    expect {
        "channel is not set properly" {
            set isError 1
            set resultStr "channel is not set properly"
        }
        "channel is set" {
            set isError 0 
            set resultStr "$chanNo"
	    log  "channel is set"
        }
        "not found" {
	    set isError 1
 	    set resultStr "script not found"
	}
        "Interface doesn't accept private ioctl..." {
            set isError 1
            set resultStr "Invalid Channel $chanNo"
        }
       timeout {
	   set isError 1
	   set resultStr "timeout:waiting for the script"
	}
    }

#    expect $dutPromptStr
    return [list $isError $resultStr ]
  }

#Test for USB
proc usb_check_fix { dutPromptStr dutSpawnId} {

    global spawn_id
    set isError ""
    set retStr ""
    set spawn_id $dutSpawnId
    clearExpectBuf $dutPromptStr 

#    send "df | grep sda | echo $?\r"
    send "df \r"
    expect {
	"/dev/sda1"  {
	    set isError 1
            set retStr "USB not found "
	} 
        "/mnt/usbdrive"  {
            set isError 0
            set retStr "USB found"
        }

	timeout {
	    set isError 1
	    set retStr "there's no USB"
	}
#        "$dutPromptStr" {
#      }
    }
    return [list $isError $retStr ]

}

# read the hw clock
# Inputs:
#   promptStr
#   spawnId
# Outputs
#  always should return success
#  list of hwtime(str),localtime(str),diff(int)
proc readHwClock { promptStr spawnId } {
    global spawn_id 

    set spawn_id $spawnId
    clearExpectBuf $promptStr


    send "ps | grep hwclock\r"
    expect "\n"
    expect {
	"hwclock" {
	    # sleep for 30 seconds
	    log "wait for hwclock to finish updating time in hw"
	    sleep 20
	}
	
	timeout {
	    #hwclock is not running. proceed
	}
    }
    expect $promptStr

    # compare between hw time and host time
    # set the timouet to 10 as hwclock takes time
    set timeout 10
    send "hwclock\r"
    expect -re "\n(.*)seconds" {
	set hwDate $expect_out(1,string)
	set hwsecs [clock scan [string range $hwDate 0 23]]
    }
    expect $promptStr

    set localDate [clock format [clock seconds]]
    set diff [expr [clock seconds] - $hwsecs]

    return [list $hwDate $localDate $diff]
}


# writes to hw clock
# Inputs:
#   dateStr
#   promptStr
#   spawnId 
# Outputs
#  list of status code and error string
proc writeHwClock { dateStr } {

    global dutPromptStr dutSpawnId

    set spawn_id $dutSpawnId
    # clear the expect buffer
    clearExpectBuf $dutPromptStr

    
    send "date \'$dateStr\'\r"
    expect $dutPromptStr 

    # then program hw clock from system time
    send "hwclock --utc --systohc \r"
    # set the timouet to 10 as hwclock takes time
    expect -timeout 10  $dutPromptStr
    # verify the write
    send "hwclock\r"
    expect {
	"2012" {
	# "we were able to set the hw clock"
	}
	-timeout 10 {
	    return [list 1 "unable to set the hwclock"]
	}
    }
    expect $dutPromptStr

    return [list 0 "we were able to set the hw clock"]
}

proc powerCycle { localHostPassword rebootTimeSecs webPowerSwitchOn webPowerSwitchOff boxIp boxPassword } {
    global localhostSpawnId localHostPromptStr 

    set spawn_id $localhostSpawnId

    # clear the expect buffer
    clearExpectBuf $localHostPromptStr

    # open the ssh session to the localhost
#    set ret [login_to_box "127.0.0.1" $localHostPassword]
#    if { [lindex $ret 0] != 0 } {
#        puts "ret: $ret"
#        set errStr "unable to login to localhost: "
#        append errStr [lindex $ret 1]
#        return [list [lindex $ret 0] $errStr]
#    } else {
#        send "$webPowerSwitchOff \r"
#        expect $localHostPromptStr
#        sleep 15
#        send "$webPowerSwitchOn \r"
#        expect $localHostPromptStr
 #  }

    sleep $rebootTimeSecs

    # Login to box after reboot
    set ret  [login_to_box $boxIp $boxPassword]
    if { [lindex $ret 0] != 0 } {
	return $ret
    }

    return $ret
}

# verify's RTC clock is functiona
#  return => list of status code and error string if any
proc rtcIsFunctional { } {

    global dutIsRsu dutPromptStr durPromptStr dutSpawnId durSpawnId localhostSpawnId savariDisableNtpOneTimeFileName dutBoxIp durBoxIp rebootTimeSecs
    global localHostPromptStr localHostPassword boxPassword webPowerSwitchOn webPowerSwitchOff 

    set resultStr " "
    set testName  "Battery     "
    set testPassed 0

    set spawn_id $durSpawnId
    # clear the expect buffer
    clearExpectBuf $durPromptStr  ;#clearout the buffer
    # Unmount the USB drive before Power Cycle using halt
  #   send "halt \n"
  #   expect  {
  #     "killall" {
  #       log "Security stops properly"
  #     }
  #       "$durPromptStr" {
  #     }
  #   }
     sleep 3

    set spawn_id $dutSpawnId

    # clear the expect buffer
    clearExpectBuf $dutPromptStr ;#clearout the buffer

    # check for rtc under proc file system
    send "ls /proc/driver/rtc\r"
    expect {
        "No such file" {
            return [list 1 "ERR: RTC file /proc/driver/rtc not found"]
        }
	"/proc/driver/rtc" {
        }
    }
    expect $dutPromptStr


   if { $dutIsRsu == 0 } {
	# check for battery status on mobiwave boards
	# streetwave boards don't have battery status
	send "cat /proc/driver/rtc | grep batt_status\r"
	expect {
	    "okay" {
	    }
	    timeout {
		return [list 1 "ERR: Battery status is invalid in /proc/driver/rtc"]
	    }
	}
	expect $dutPromptStr
     }
    send "hwclock \r"
    set isError 0
    expect {
	-re "\n(.*)seconds" {
	    set hwDate $expect_out(1,string)
	}

	timeout {
	    if { $dutIsRsu == 0 } {
		return [list 1 "timeout reading hwclock"]
	    }
	    # on RSU, I2C NEEDED TO BE PROGRAMMED FOR RTC. On some of RSU boards i2c is not 
	    # properly programmed
	    set isError 1
	}
    }
    expect $dutPromptStr

    if { $dutIsRsu == 1 && $isError == 1 } {

	# i2c enable for rtc
	send "i2cset -f -y 0 0x68 0 0xb109 w\n"
	expect {
	    "readback matched" {
	    }

	    timeout {
		return [ list 1 "unable to program the board with i2c for rtc clock enable"]
	    }
	}
	expect $dutPromptStr

	send "i2cset -f -y 0 0x68 0x4 0x4612 w\n"
	expect {
	    "readback matched" {
	    }

	    timeout {
		return [ list 1 "unable to program the board with i2c for rtc clock enable"]
	    }
	}
	expect $dutPromptStr

    }

    # Disable the GPS modules in the box

       send "/etc/init.d/gpsd stop \r"
       expect {
           "Terminated" {
             log "GPSd stopped properly"
             sleep 4 
          }
          -timeout 50 "$dutPromptStr" {
          }
       }
       send "/etc/init.d/gpsd disable \r"
       expect -timeout 50 $dutPromptStr
       sleep 2  

    # program the hwclock
      
    #   set date70Str "2012-03-12 12:12:00"

    set date70Str 0312121202012
    log "set the date to $date70Str"
    set ret [writeHwClock $date70Str]
    if { [lindex $ret 0] != 0 } {
	return $ret
    }
    sleep 1
    send "hwclock \r"
    expect -timeout 10 -re "\n(.*)seconds" {
        set hwClockDate $expect_out(1,string)
        set hwClockSetSecs [clock scan [string range $hwClockDate 0 23]]
    }

    # Unmount the USB drive before Power Cycle using halt
#     send "halt \n"
#     expect  {
#       "killall" {
#         log "Security stops properly"
#       }
#         "$dutPromptStr" {
#       }
#     }
     sleep 3


    # Power Cycle the DUT box using WEB power switch
    set ret [powerCycle $localHostPassword $rebootTimeSecs $webPowerSwitchOn $webPowerSwitchOff $dutBoxIp $boxPassword]
    if { [lindex $ret 0] != 0 } {
	return $ret
    } else {
	set dutPromptStr [lindex $ret 1]
	set dutSpawnId   [lindex $ret 2]
	set spawn_id $dutSpawnId
    }

    send "hwclock \r"
    expect -timeout 10 -re "\n(.*)seconds" {
	set curHwDate $expect_out(1,string)
	set curHwSecs [clock scan [string range $curHwDate 0 23]]
    }

    
    # max time difference  should be rebootTimeSecs + delta
    set maxTimeDiffSecs [expr $rebootTimeSecs + 90 ]
    set timeDiffSecs [expr $curHwSecs - $hwClockSetSecs ]

    send "/etc/init.d/gpsd enable \r"
    expect -timeout 50 $dutPromptStr


    send "/etc/init.d/gpsd start \r"
    expect {
          "Timed out" {
          #GPSd time out wait for 30secs
          sleep 30
          }
          "115200" {
          }
          "9600" {
          }  
           -timeout 50 "$dutPromptStr" {
          }
     }
     sleep 5
 
     # Execute halt and run make sure that BSMs are trasmitting
     send "halt \n"
     expect  {
       "killall" {
         log "Security stops properly"
       }
         "$dutPromptStr" {
       }
     }
     sleep 5
     send  "run \n"
     expect -timeout 10 $dutPromptStr
     sleep 5



    # Login to box after reboot
    set ret  [login_to_box $durBoxIp $boxPassword]
     if { [lindex $ret 0] != 0 } {
        return $ret
    } else {
        set durPromptStr [lindex $ret 1]
        set durSpawnId   [lindex $ret 2]
        set spawn_id $durSpawnId
    }

     # Enaable the GPS modules in the box  after completion of test
    
    # just in case, put a check for -ve value also
    if {  $timeDiffSecs > $maxTimeDiffSecs ||  $timeDiffSecs == 0 ||  $timeDiffSecs < [expr 0 - $maxTimeDiffSecs] } {
	set resultStr "hwclock is not functional. Diff:$curHwSecs  after reboot:$hwClockSetSecs   before reboot:$timeDiffSecs   allowedTimeDiff:$maxTimeDiffSecs"
        set testPassed 0
        sleep 3
    } else {
      log "hwclock is functional. $timeDiffSecs < $maxTimeDiffSecs"
    set testPassed 1
    sleep 3
    }
 
    if { $testPassed == 1 } {
	set testFailed 0
    } else {
	set testFailed 1
    }

     return [list $testFailed $resultStr $testName $timeDiffSecs]

}


# randomizes the list 
proc randList { list } {

   # determine length of list
    set listlength [llength $list]
    
   # iterate on list, decrease length per iteration 
    for { set i $listlength } { $i > 1 } { incr i -1 } {
      # choose random index 
	set randindex [expr int(rand()*$listlength)]
      # pick the random item
	set randitem [lindex $list $randindex]
      # cut the random item from the list
	set list [lreplace $list $randindex $randindex]
      # paste the random item at the end of the list
	set list [lappend list $randitem]
    }
   return $list
}



proc  logStartTest { { text  "" } } {

    log "\n\n==========BEGIN [lindex [info level -1] 0]: $text Date: [clock format [clock seconds]]=======\n"
}

proc  logEndTest { { text  "" } } {
    log "\n\n==========END [lindex [info level -1] 0]: $text  Date: [clock format [clock seconds]]=======\n"
}

proc logTestOk { msg } {
    log "\n\nTEST [lindex [info level -1] 0] Succeeded $msg\n"
}

proc logTestFail {  msg } {
    log "\n\nTEST [lindex [info level -1] 0] FAILED $msg\n"
}



# pre main sets environment for main execution to run
# returns status and error message
proc  preMain {} {
    global testsRegExp testListToExecute logFileHdl dutIsRsu randomizeTests  preImageFile preImageUpgradeCleanConfig
    global dutBoxIp durBoxIp durPromptStr durSpawnId dutPromptStr dutSpawnId localhostSpawnId commonTimeoutSecs rebootTimeSecs
    global username boxPassword localHostPassword localHostPromptStr scpRemoteIp
    global argv spawn_id executeFromFile preDurImageFile
    global dsrcEssid dsrcIntfName dutDsrcIp durDsrcIp buildType site
    global wifiEssid dutWifiIntfName dutWifiIp durWifiIp
    global rsuManufactureTestRegExp obuManufactureTestRegExp rsuFailSafeTestRegExp
    global stopAtFail dutBoxMac dutBoxMacIntfName pingNumPkts
    global dutWifiMac dutDsrcMac dutBtMac btIntfName dutIsRsuFailSafe
    global webPowerSwitchOff webPowerSwitchOn logFileLocation
 
    log_user 1
    set timeout $commonTimeoutSecs

    set dutOff 1
    set durOff 1

    parseCmdLine $argv
    
    # log the spawned session output to the file aswell
#    log_file -open $logFileHdl

    # expand reg exp indicating tests to execute  and sort
#    if { $randomizeTests == 0 } {
#	set testListToExecute [lsort -ascii [info procs]]
#    } else {
#	set testListToExecute [randList [info procs]]
#    }
    # Check for rse build
#    if { [string first "StreetWAVE" $preImageFile] >= 0 } {  
     if { $buildType == 1 } { 
       log "This is ASD build"
      # set testListToExecute "bsm_test"
       set testListToExecute "setConfig_test system_test gps_test pps_test channel_test datarate_test txpower_test usb_test dsrc_test ethernet_test lanipaddrchange_test  bsm_test ipv6_test wsm_test dsrcFwd_test upload_test status1_test"
   } elseif { $buildType == 2 } {
       log "This is rse build" 
#        set testListToExecute "wsm_test"

        set testListToExecute "setConfig_test firmwareUpgrade_test timapp_test dsrcproxy_test system_test gps_test pps_test channel_test datarate_test txpower_test usb_test dsrc_test ethernet_test lanipaddrchange_test bsm_test ipv6_test wsm_test dsrcFwd_test upload_test status1_test"

      } else {
        log "This is default"   
        set testListToExecute [randList [info procs]]  
  }
    # Execute the list of test from file
    if { $executeFromFile != "" } {
        if { [catch {set executeFromFileHdl [open $executeFromFile ]}] != 0 } {
	    return  [list 1 " Unable to open $executeFromFile."]
	} else {
	    set testListToExecute [read $executeFromFileHdl]
	}


	# rsu manufacturing support
    } elseif { "$testsRegExp" == "$rsuManufactureTestRegExp" } {
	#set testListToExecute  "dsrc_a_noChanSwitch_ping_test dsrc_c_noChanSwitch_iperf_test wifi_d_wpa2_ping_test wifi_h_wpa2_iperf_test bt_a_scan_test gps_a_fix_test threeg_a_check_conn_test system_a_rtc_is_functional_test   system_b_ntp_test 
	set testListToExecute "a_scpboard_test a_scpusb_test pps_test gps_test eth_ping_test usb_test channel_test"

	# normal automation

    } elseif { "$testsRegExp" == "$rsuFailSafeTestRegExp" } {

	#set testListToExecute  "wifi_d_wpa2_ping_test wifi_h_wpa2_iperf_test bt_a_scan_test gps_a_fix_test threeg_a_check_conn_test system_a_rtc_is_functional_test   system_b_ntp_test system_c_watchdog_test"
	set testListToExecute "a_scpboard_test a_scpusb_test pps_test gps_test eth_ping_test usb_test channel_test"
 
	# normal automation

    } else {
    
	# filter out any procedures which doesn't have _test in them
	# we can't execute utility functions from test automation directly
	set temp {}
	foreach  testToExecute $testListToExecute {

	    if { [string first _test "$testToExecute"] == -1 } {
		continue
	    }
	    # set it to null string. In case of no match, the variable will
	    # not be set by regexp
	    set matched ""
	    regexp  "$testsRegExp" $testToExecute  matched 
	    if { $matched != $testToExecute } {
		continue
	    }

	    lappend  temp "$testToExecute"
	}
	set testListToExecute "$temp"
    }

    log "list of tests: $testListToExecute"
    log "wait for 5secs" 
    sleep 5

    # open the ssh session to the localhost
#    set ret [login_to_box "127.0.0.1" $localHostPassword]
#    if { [lindex $ret 0] != 0 } {
#	puts "ret: $ret"
#	set errStr "unable to login to localhost: "
#	append errStr [lindex $ret 1]
#	return [list [lindex $ret 0] $errStr]
 #   } else {
#	set localHostPromptStr [lindex $ret 1]
#	set localhostSpawnId   [lindex $ret 2]
#	clearExpectBuf $localHostPromptStr
	# delete the file as copy the image from localhost to dut
#	send "rm -f ~/.ssh/known_hosts\r"
#	expect $localHostPromptStr
 #   }

    # Ping to check board is accessible or not
#    send "ping -c $pingNumPkts -q $dutBoxIp\r"
#    expect   {

        # SREENI NEED TO TAKE LOOK AT THIS. WHY 80SEC TIMEOUT
 #       -timeout 80
#-re "\(\[1-9]) packets received" 

  #      -re "\(\[1-9]) received" {
  #          log "got packets,board is accessible"
  #      }

  #      "0 received" {
  #          return [list 1 "ERR: ping: 0 packets rcvd. no connectivity" 0]
  #      }
   #     timeout {
   #         return [list 1 "ERR: ping: expect timeout" 0]
   #     }
   # }

#### Login to ftp to download the image

#spawn ftp $site
#connect
#while {[connect]} {
#send "quit\r"
#expect eof
#spawn ftp $site
#}
#send "binary\r"
#send "cd DOT_RSE\r"
#send "get $preImageFile\r"
#send "quit\r"
#expect eof

# open the ssh session to dut
    set ret [login_to_box $dutBoxIp $boxPassword "51012"]
    if { [lindex $ret 0] != 0 } {
       set dutOff 1
    } else {
       set dutOff 0
    }

    if { $dutOff == 0} {
    set dutPromptStr [lindex $ret 1]
    set dutSpawnId   [lindex $ret 2]
    puts  "$dutSpawnId"
    puts "[lindex $ret 1]"
    puts "[lindex $ret 2]"
    clearExpectBuf $dutPromptStr ;#clearout the buffer
}
    send "uname -m\r"
    expect {

	-timeout 5

	"i586" {
	    set dutIsRsu 0
	    set dutWifiIntfName "ath1"
	}

	-re "arm*" {
	    set dutIsRsu 1
	    set dutWifiIntfName "ath2"
	}

	timeout {
	    return [list 1  "Unable to determine the box type for DUT"]
	}
    }
    expect $dutPromptStr
    # check if image is failsafe, set the flag dutIsRsuFailSafe
    if { [string first "FS" "$dutPromptStr"] != -1 } {
      set dutIsRsuFailSafe 1
    }

    
    # check for image running  (failsafe or regular ) in the box depending upon image file supplied 
    if { $preImageFile != "" && $dutIsRsu == 1 &&
	 (( [string first "FS" $dutPromptStr]  == -1  && [string first "FS" $preImageFile] != -1 ) ||
	  ([string first "FS" $dutPromptStr]  != -1  && [string first "FS" $preImageFile] == -1 ) )}  {
	# image supplied is fail safe but box not booted fail safe image or vice versa 

	if { [string first "FS" $preImageFile] != -1 } {
	    send "flash_update.sh -c 4 -t 1\r"
	} else {
	    send "flash_update.sh -c 1 -t 0\r"
	}
	# set through flash update to boot with image from (failover or regular) at next boot
	expect -timeout 5 $dutPromptStr

	set ret [rebootBox "Rebooting the box for image switchover..." $dutPromptStr $dutBoxIp $dutSpawnId $rebootTimeSecs 0 $dutIsRsu]
	if { [lindex $ret 0] != 0 } {
	    return $ret
	}
	
	set dutPromptStr [lindex $ret 1]
	set dutSpawnId   [lindex $ret 2]
	clearExpectBuf $dutPromptStr ;#clearout the buffer
	#make sure that box is booted in right 
	if { ( [string first "FS" $dutPromptStr]  == -1  && [string first "FS" $preImageFile] != -1 ) ||
	     ([string first "FS" $dutPromptStr]  != -1  && [string first "FS" $preImageFile] == -1  ) } {
	    return [list 1 "Unable to switch image on the box"]
	}
    }	

    # copy the preImage file to the DUT on /tmp
    if { $preImageFile == "" } {
#	set ret [fwUpgrade $dutBoxIp $username $boxPassword  $dutSpawnId $dutPromptStr $localhostSpawnId $localHostPromptStr $preImageFile $preImageUpgradeCleanConfig ]	
	set ret [fwUpgrade $scpRemoteIp $username $localHostPassword $dutSpawnId $dutPromptStr $dutSpawnId $dutPromptStr $logFileLocation/$preImageFile 1]
	if { [lindex $ret 0] != 0 } {
	    return $ret
	} else {
	    set dutPromptStr [lindex $ret 1]
	    set dutSpawnId   [lindex $ret 2]
	}
    }

    set ret [getMac $dutBoxMacIntfName $dutPromptStr]
    if { [lindex $ret 0] == 0 } {
	set dutBoxMac [lindex $ret 1]
    }
    set ret [getMac $dutWifiIntfName $dutPromptStr]
    set ret [getMac $btIntfName $dutPromptStr]
    # on failsafe image, no dsrc intf exist 
    if { [string first "FS" $dutPromptStr]  == -1 }  {

	set ret [getMac $dsrcIntfName $dutPromptStr]
	if { [lindex $ret 0] == 0 } {
	    set dutDsrcMac [lindex $ret 1]
	}

	# find out the default dsrc essid on dut box
	send "iwconfig $dsrcIntfName\r"
	expect {
	    "No such device" {
	      log "$dsrcIntfName is not found on DUT"
	    }

	    -re "ESSID:\"(.*)\" " {
		set dsrcEssid $expect_out(1,string)
	    }

	}
	expect $dutPromptStr

	# decide durDsrcIp based on dutDsrcIp
        send "ifconfig $dsrcIntfName $dutDsrcIp netmask 255.255.255.0 \r"
        expect  "$dutPromptStr"
 
	send "ifconfig $dsrcIntfName\r"
	expect {
	    "No such device" {
                log  "$dsrcIntfName is not found on DUT"
            } " Device not found" {
	      	log "$dsrcIntfName is not found on DUT"
	    }
	    -re "inet addr:(\[0-9]*)\.(\[0-9]*)\.(\[0-9]*)\.(\[0-9]*)" {
		set ipLastByte $expect_out(4,string)
		incr ipLastByte
		set durDsrcIp ""
		set dutDsrcIp ""
		append durDsrcIp $expect_out(1,string) "." $expect_out(2,string) "." $expect_out(3,string) "." $ipLastByte
		append dutDsrcIp $expect_out(1,string) "." $expect_out(2,string) "." $expect_out(3,string) "." $expect_out(4,string)
		log "dutDsrcIp: $dutDsrcIp , durDsrcIp: $durDsrcIp "
	    }
	}
	expect $dutPromptStr

       sleep 3

#      };# if { [string first "FS" $dutPromptStr]  != -1 } 
 #}
    #create session to dur box
    set ret [login_to_box $durBoxIp $boxPassword "22"]
   if { [lindex $ret 0] != 0 } {
       set durOff 1
    } else {
       set durOff 0
    }

    if { $durOff == 0} {
	 set durPromptStr [lindex $ret 1]
    set durSpawnId   [lindex $ret 2]
    puts  "$durSpawnId"
    puts "[lindex $ret 1]"
    puts "[lindex $ret 2]"
    clearExpectBuf $durPromptStr  
}
     send "uname -m\r"
      expect {

	-timeout 1

	"i586" {
	    set durIsRsu 0
	}

	-re "arm*" {
	    set durIsRsu 1
	}

	timeout {
	    return [list 1 "unable to determine the box type for DUT"]
	}
      }
#    set durPromptStr [lindex $ret 1]
#    set durSpawnId $spawn_id
   
 

  #  sleep $rebootTimeSecs
    
    #Log into DUT Box
#    set ret [login_to_box $dutBoxIp $boxPassword]
#    if { [lindex $ret 0] != 0 } {
#        set ret [login_to_box "127.0.0.1" $localHostPassword]
#        if { [lindex $ret 0] != 0 } {
#        set errStr "unable to login to localhost: "
#        return [list [lindex $ret 0] $errStr]
#        } else {
#        log " Unable to login to DUT \r"
#        send "cd $logFileLocation \r" 
#        send "\n\n cat warningMessage.txt \n\n \r"
#        expect $localHostPromptStr
#        return [list 1 "Unable to login to DUT: [lindex $ret 1]"]
#      }
#    }
#    set dutPromptStr [lindex $ret 1]
#    set dutSpawnId   [lindex $ret 2]
#    clearExpectBuf $dutPromptStr ;#clearout the buffer

    return [list 0 ""]
}


# main procedure which exceutes the tests
proc main { count } {
    global testListToExecute testBetweenSecs logFileHdl summaryFile stopAtFail dutBoxMac dutPromptStr dutBoxMacIntfName saveTestExecutionListToFile
    global dutWifiMac dutDsrcMac dutBtMac dutIsRsuFailSafe testName localHostPromptStr  
    
    set  testNames    [list]
    set  testResult(none)   "0"
    set  testString(none)   "0"
    set  summary      ""
    set  exitStatus   0
    # first run the preMain
    set ret [preMain]

    if { [lindex $ret 0] == 0 } {
       
	log ""
	log "Testing start for $dutBoxMac ( of $dutBoxMacIntfName ) board($dutPromptStr) at Date: [clock format [clock seconds]]"
	log "==================================================================================\n\n"

	logTestParams
	log ""
	log ""
	log "box(eth0)Mac: $dutBoxMac , dsrcMac: $dutDsrcMac"

	# walk through tests to execute

	foreach  testToExecute $testListToExecute {
            if { $dutIsRsuFailSafe == 0 &&  [string first _alterIntf $testToExecute] != -1 } {
               continue 
             }

	    #execute test
	    set ret [$testToExecute]
	    set procNameStr($testToExecute) $testName	
	    # save the test results
	    lappend testNames  $testToExecute
            #log  "$testToExecute return value: $ret"
	    if { [lindex $ret 0] != 0 } {
		set    testResult($testToExecute)  "FAIL([lindex $ret 0]) at Date: [clock format [clock seconds]]"
		set    testString($testToExecute)  [lindex $ret 1]
		set    exitStatus                  [lindex $ret 0]
		if { $stopAtFail != 0 } {
		    break
		}
	    } else {
#		set    testResult($testToExecute)  "Pass at Date: [clock format [clock seconds]]"
		set    testString($testToExecute)  [lindex $ret 1]
	    }
	    log "Wait for $testBetweenSecs secs to see the result"
	    sleep $testBetweenSecs
	} 

	#produce summary string
	foreach testExecuted  $testNames {
	    #append summary "$testExecuted\t"
	    append summary "$procNameStr($testExecuted)\n"
#            append summary "$testResult($testExecuted)\t"
	    append summary "\t\t\t\t\t$testString($testExecuted)\n"
	    }
#	    append summary "\n\n\t\t\tSystem informatin\n\n"

    } else {
	append summary "preMain\t"
	append summary "Fail\t"
	append summary "[lindex $ret 1]\n"
	set    exitStatus  "[lindex $ret 0]"
    }
    
    log "\n\n\nTest Summary for RSE\nTested on: [clock format [clock seconds]]\nEthernet Mac address:$dutBoxMac\n\n$summary"
    if { $summaryFile != "" } {

	# open the summary file
	if { [catch {set summaryFileHdl [open $summaryFile a+]}] != 0 } {
	    puts stderr " Unable to open $summaryFile."
	    exit 1
        }
             
       
        puts $summaryFileHdl "Loop started :$count " 
	puts  $summaryFileHdl "\nTest Summary for RSE\nTested on: [clock format [clock seconds]]\nEthernet Mac address:$dutBoxMac\n\n$summary"
	close $summaryFileHdl
    }




    log ""
    log "Testing end for $dutBoxMac ( of $dutBoxMacIntfName ) board($dutPromptStr) at Date: [clock format [clock seconds]]"
    log "======================================================================================\n\n"

#    close $logFileHdl

    if { $exitStatus != 0 } {
       # Save test execution list to file
	if { $saveTestExecutionListToFile != "" } {

	    # open the test list file
	    if { [catch {set testListToExecuteFileHdl [open $saveTestExecutionListToFile w+]}] != 0 } {
		log  " Unable to open $saveTestExecutionListToFile."
	    } else {
		if { $testListToExecute != ""} {
		    puts $testListToExecuteFileHdl $testListToExecute
		    close $testListToExecuteFileHdl
		}
	    }
	}
    }
     exit $exitStatus
interact


trap {
    global ignoreTrap
    puts "SIGCHLD Received"
    if { $ignoreTrap == 0 } {
	if [catch {wait -i -1} output ] return
	puts "Caught SIGCHILD ([llength $output] lines returned)"
	puts "pid is [lindex $output 0], status is [lindex $output 2], ExitVal = [lindex $output 2]"
    }
} SIGCHLD

}





